#+TITLE: The GridFire Fire Behavior Model
#+AUTHOR: Gary W. Johnson, Ph.D., David Saah, Ph.D., Max Moritz, Ph.D.
#+DATE: Copyright 2011-2020 Spatial Informatics Group, LLC
#+OPTIONS: ^:{} toc:nil h:3
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage[left=1in]{geometry}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \usepackage{wrapfig}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \usepackage{epsfig}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[round,comma]{natbib}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \setlength{\headheight}{13.6pt}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     linkbordercolor=black,
#+LATEX_HEADER:     linkcolor=black}

* Preface

This document is a Literate Program[fn::
https://en.wikipedia.org/wiki/Literate_programming], containing both
the source code of the software it describes as well as the rationale
used in each step of its design and implementation. The purpose of
this approach is to enable anyone sufficiently experienced in
programming to easily retrace the author's footsteps as they read
through the text and code. By the time they have reached the end of
this document, the reader should have just as strong a grasp of the
system as the original programmer.

To execute the code illustrated within this document, you will need to
install several pieces of software, all of which are open source
and/or freely available for all major operating systems. These
programs are listed in Table [[tab:required-software]] along with their
minimum required versions and URLs from which they may be downloaded.

#+NAME: tab:required-software
#+CAPTION: Software necessary to evaluate the code in this document
#+ATTR_LATEX: :align |l|r|l| :font \small
|----------------------+-------------+--------------------------------------------|
| Name                 |     Version | URL                                        |
|----------------------+-------------+--------------------------------------------|
| Java Development Kit |         11+ | https://jdk.java.net                       |
| Clojure CLI Tools    | 1.10.1.561+ | https://clojure.org/guides/getting_started |
| Postgresql           |         10+ | https://www.postgresql.org/download        |
| PostGIS              |          3+ | https://postgis.net/install                |
|----------------------+-------------+--------------------------------------------|

GridFire is written in the Clojure programming language[fn::
https://clojure.org], which is a modern dialect of Lisp hosted on the
Java Virtual Machine.\citep{Hickey2008} As a result, a Java
Development Kit is required to compile and run the code shown
throughout this document.

The Clojure CLI tools are used to download required libraries and
provide a code evaluation prompt (a.k.a. REPL) into which we will
enter the code making up this fire model.

Postgresql (along with the PostGIS spatial extensions) will be used to
load and serve raster-formatted GIS layers to the GridFire program.
Although it is beyond the scope of this document, PostGIS provides a
rich API for manipulating both raster and vector layers through SQL.
See https://postgis.net for more information.

*License Notice*: All code presented in this document is solely the
work of the authors (Gary W. Johnson, Ph.D., David Saah, Ph.D., Max
Moritz, Ph.D.) and is made available by Spatial Informatics Group,
LLC. (SIG) under the Eclipse Public License version 2.0 (EPLv2)
https://www.eclipse.org/legal/epl-2.0/. Please contact Gary Johnson
(gjohnson@sig-gis.com), David Saah (dsaah@sig-gis.com), or Max Moritz
(mmoritz@sig-gis.com) for further information about this software.

* Setting Up the Clojure Environment
** Build Configuration: deps.edn

Because Clojure is implemented on the Java Virtual Machine (JVM), we
must explicitly list all of the libraries used by our program on the
Java classpath. Fortunately, the Clojure CLI tools can handle
downloading and storing these libraries as well as making them
available to the Clojure process at runtime. However, in order for
Clojure to know which libraries are needed, we must first create its
build configuration file, called ``deps.edn'', and place it in the
directory from which we will call our Clojure program. A minimal but
complete deps.edn is shown below.

#+name: deps.edn
#+begin_src clojure :results silent :exports code :tangle ../deps.edn :padline no :no-expand :comments link
{:paths ["src" "resources"]

 :deps {org.clojure/clojure                 {:mvn/version "1.10.1"}
        org.clojure/data.csv                {:mvn/version "1.0.0"}
        org.clojure/java.jdbc               {:mvn/version "0.7.11"}
        org.clojure/spec.alpha              {:mvn/version "0.2.187"}
        org.clojure/core.specs.alpha        {:mvn/version "0.2.44"}
        org.postgresql/postgresql           {:mvn/version "42.2.16"}
        net.mikera/core.matrix              {:mvn/version "0.62.0"}
        net.mikera/vectorz-clj              {:mvn/version "0.48.0"}
        sig-gis/magellan                    {:mvn/version "20210113"}
        org.clojars.lambdatronic/matrix-viz {:mvn/version "0.1.7"}
        org.clojure/tools.cli               {:mvn/version "1.0.194"}
        kixi/stats                          {:mvn/version "0.5.4"}}

 :mvn/repos {"osgeo" {:url "https://repo.osgeo.org/repository/release/"}}

 :aliases {:build-test-db {:extra-paths ["test"]
                           :main-opts   ["-m" "gridfire.build-test-db"]}
           :run           {:main-opts ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                       "-m" "gridfire.cli"]}
           :repl          {:main-opts ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                       "-e" "(require,'gridfire.cli)"
                                       "-e" "(in-ns,'gridfire.cli)"
                                       "-r"]}
           :make-config   {:main-opts ["-m" "gridfire.config"]}
           :make-uberjar  {:extra-deps {seancorfield/depstar {:mvn/version "1.0.97"}}
                           :main-opts  ["-m" "hf.depstar.uberjar" "target/gridfire-20200909.105353.jar"
                                        "-C" "-m" "gridfire.cli"]}
           :test          {:extra-paths ["test"]
                           :extra-deps  {com.cognitect/test-runner
                                         {:git/url "https://github.com/cognitect-labs/test-runner.git"
                                          :sha     "209b64504cb3bd3b99ecfec7937b358a879f55c1"}}
                           :main-opts   ["-e" "(do,(set!,*warn-on-reflection*,true),nil)"
                                         "-m" "cognitect.test-runner"]}
           :check-deps    {:extra-deps {olical/depot {:mvn/version "1.8.4"}}
                           :main-opts  ["-m" "depot.outdated.main"]}}}
#+end_src

Once this file is created, we need to instruct Clojure to download
these library dependencies and then run the built-in test suite to
verify that GridFire compiles and runs as expected on our local
computer.

Before we run tests we'll need to setup a test database and import
rasters into it. We will be prompted for the postgres and
gridfire_test user's password. Postgres user's password will be
whatever it is when we setup Postgres. For gridfire_test user's
password refer to ``src/sql/create_test_db.sql''

#+name: clojure-test-db
#+begin_src sh :results silent :exports code
clojure -A:build-test-db
#+end_src

To run tests

#+name: clojure-test
#+begin_src sh :results silent :exports code
clojure -A:test
#+end_src

** Project Metadata: pom.xml

POM is an acronym for Project Object Model and is a necessary
component of any redistributable project built to run on the Java
Virtual Machine. The pom.xml file contains project metadata, such as
the application name and version, its dependencies and the URLs of
code repositories from which to download them, and any additional
information that is necessary to package GridFire as an ``uberjar``.
The advantage of the uberjar format (e.g., gridfire-<version>.jar) is
that the single uberjar file can be shared easily between computers
and can be run by anyone with a recent version of Java installed,
without needing to install Clojure, Git, or any of the dependency
libraries that GridFire uses.

The following command will create an initial pom.xml for our project
based on the contents of our deps.edn from the previous section.

#+name: clojure-pom
#+begin_src sh :results silent :exports code
clojure -Spom
#+end_src

Once this file is created, we need to modify the contents of its XML
tags to add any additional information that was not availabe from
deps.edn, such as the project name, version, and description.

#+name: pom.xml
#+begin_src xml :results silent :exports code :tangle ../pom.xml :padline no :no-expand :comments link
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>sig-gis</groupId>
  <artifactId>gridfire</artifactId>
  <version>20200909.105353</version>
  <name>gridfire</name>
  <description>
    SIG's Raster-based Fire Behavior Model
  </description>
  <build>
    <plugins>
      <plugin>
        <configuration>
          <archive>
            <manifestEntries>
              <Specification-Title>Java Advanced Imaging Image I/O Tools</Specification-Title>
              <Specification-Version>1.1</Specification-Version>
              <Specification-Vendor>Sun Microsystems, Inc.</Specification-Vendor>
              <Implementation-Title>com.sun.media.imageio</Implementation-Title>
              <Implementation-Version>1.1</Implementation-Version>
              <Implementation-Vendor>Sun Microsystems, Inc.</Implementation-Vendor>
            </manifestEntries>
          </archive>
        </configuration>
      </plugin>
    </plugins>
    <sourceDirectory>src</sourceDirectory>
  </build>
  <dependencies>
    <dependency>
      <groupId>org.clojure</groupId>
      <artifactId>clojure</artifactId>
      <version>1.10.1</version>
    </dependency>
    <dependency>
      <groupId>sig-gis</groupId>
      <artifactId>magellan</artifactId>
      <version>20200909.105353</version>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>42.2.16</version>
    </dependency>
    <dependency>
      <groupId>org.clojars.lambdatronic</groupId>
      <artifactId>matrix-viz</artifactId>
      <version>0.1.7</version>
    </dependency>
    <dependency>
      <groupId>org.clojure</groupId>
      <artifactId>data.csv</artifactId>
      <version>1.0.0</version>
    </dependency>
    <dependency>
      <groupId>org.clojure</groupId>
      <artifactId>java.jdbc</artifactId>
      <version>0.7.11</version>
    </dependency>
    <dependency>
      <groupId>net.mikera</groupId>
      <artifactId>vectorz-clj</artifactId>
      <version>0.48.0</version>
    </dependency>
    <dependency>
      <groupId>net.mikera</groupId>
      <artifactId>core.matrix</artifactId>
      <version>0.62.0</version>
    </dependency>
  </dependencies>
  <repositories>
    <repository>
      <id>clojars</id>
      <url>https://repo.clojars.org/</url>
    </repository>
    <repository>
      <id>osgeo</id>
      <url>https://repo.osgeo.org/repository/release/</url>
    </repository>
  </repositories>
</project>
#+end_src

Once the pom.xml has been configured correctly, we can compile
GridFire and package it up as an uberjar (under
target/gridfire-<version>.jar) by running the following command:

#+name: clojure-make-uberjar
#+begin_src sh :results silent :exports code
clojure -A:make-uberjar
#+end_src

* Setting Up the PostGIS Database

GridFire may make use of any raster-formatted GIS layers that are
loaded into a PostGIS database. Therefore, we must begin by creating a
spatially-enabled database on our local Postgresql server.

When installing Postgresql, we should have been prompted to create an
initial superuser called *postgres*, who has full permissions to
create new databases and roles. We can log into the Postgresql server
as this user with the following *psql* command.

#+name: connect-to-postgresql-server-as-postgres
#+begin_src sh :results silent :exports code
psql -U postgres
#+end_src

Once logged in, we issue the following commands to first create a new
database role and to then create a new database (owned by this role)
in which to store our raster data. Finally, we import the PostGIS
spatial extensions into the new database.

#+name: create-gridfire-db
#+begin_src sql :engine postgresql :cmdline -U postgres :results silent :exports code
CREATE ROLE gridfire WITH LOGIN CREATEDB;
CREATE DATABASE gridfire WITH OWNER gridfire;
\c gridfire
CREATE EXTENSION postgis;
#+end_src

* Importing Rasters into the Database

Whenever we want to add a new raster-formatted GIS layer to our
database, we can simply issue the *raster2pgsql* command as follows,
replacing the raster name and table name to match our own datasets.

#+name: raster2pgsql-import-example-single
#+begin_src sh :results silent :exports code
SRID=4326
RASTER=dem.tif
TABLE=dem
DATABASE=gridfire
raster2pgsql -s $SRID $RASTER $TABLE | psql $DATABASE
#+end_src

*Note:* The raster2pgsql command has several useful command line
options, including automatic tiling of the raster layer in the
database, creating fast spatial indeces after import, or setting
raster constraints on the newly created table. Run *raster2pgsql -?*
from the command line for more details.

Here's an example shell script that will tile multiple large rasters
(asp.tif, cbd.tif, cbh.tif, etc) into 100x100 tiles and import them
into our database.

*Note:* Here we specified a schema (e.g, landfire) along with the table
name so as to match the sample config file in
``resources/sample_config.edn''.

First create the schema in our database.

#+name: create-landfire-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA landfire;
#+end_src

Then we can use the following script to import LANDFIRE layers into
our database given the username and schema as inputs.

*Note:* This script needs to be run in the same folder as where these
rasters reside. The filenames of these rasters should match the
elements in the for loop (i.e. asp.tif, cbd.tif etc)
#+name: raster2pgsql-import-example-all
#+begin_src sh :results silent :exports code :tangle ../resources/import_landfire_rasters.sh :padline no :no-expand :comments link
#!/bin/sh

USERNAME=$1
SCHEMA=$2
SRID=$3

for LAYER in asp cbd cbh cc ch dem fbfm13 fbfm40 slp
do
    raster2pgsql -t auto -I -C -s $SRID $LAYER.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
done
#+end_src

To run the script, give it our username, schema, and srid we wish the layers to
have.

#+begin_src sh
sh import_landfire_rasters.sh gridfire landfire 90914
#+end_src

Whenever we want to add a new spatial reference system to our
database, we can insert a record into our spatial_ref_sys table.

#+name: insert-spatial-reference-systems
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
INSERT INTO public.spatial_ref_sys (srid, auth_name, auth_srid, srtext, proj4text)
VALUES (900914, 'user-generated', 900914,
        'PROJCS["USA_Contiguous_Albers_Equal_Area_Conic_USGS_version",' ||
        'GEOGCS["NAD83",' ||
        'DATUM["North_American_Datum_1983",' ||
        'SPHEROID["GRS 1980",6378137,298.2572221010002,' ||
        'AUTHORITY["EPSG","7019"]],' ||
        'AUTHORITY["EPSG","6269"]],' ||
        'PRIMEM["Greenwich",0],' ||
        'UNIT["degree",0.0174532925199433],' ||
        'AUTHORITY["EPSG","4269"]],' ||
        'PROJECTION["Albers_Conic_Equal_Area"],' ||
        'PARAMETER["standard_parallel_1",29.5],' ||
        'PARAMETER["standard_parallel_2",45.5],' ||
        'PARAMETER["latitude_of_center",23],' ||
        'PARAMETER["longitude_of_center",-96],' ||
        'PARAMETER["false_easting",0],' ||
        'PARAMETER["false_northing",0],' ||
        'UNIT["metre",1,' ||
        'AUTHORITY["EPSG","9001"]]]',
        '+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0' ||
        ' +datum=NAD83 +units=m +no_defs');
#+end_src

We may also want to import initial ignition rasters into our database.
We can do so with a similar script as importing LANDFIRE rasters.

First create a new schema.

#+name: create-ignition-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA ignition;
#+end_src

Then we can use the following script to import an ignition raster into
our database given the schema and username as inputs.

*Note:* This script needs to be run in the same folder as where this
raster resides. The filename of this raster should match the value
assigned to the LAYER variable (i.e., ign) plus a .tif extension.

#+name: raster2pgsql-import-ignition-raster
#+begin_src sh :results silent :exports code :tangle ../resources/import_ignition_rasters.sh :padline no :no-expand :comments link
#!/bin/sh

USERNAME=$1
SCHEMA=$2
SRID=$3

LAYER="ign"
raster2pgsql -I -C -t auto -s $SRID $LAYER.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
#+end_src

To run the script, give it the username, schema name, and srid we wish the layers to have.

#+begin_src bash
sh import_ignition_rasters.sh gridfire ignition 90014
#+end_src

We may also want to import weather rasters into our database.
We can do so with a similar script as importing LANDFIRE rasters.

First create a new schema.

#+name: create-weather-schema
#+begin_src sql :engine postgresql :cmdline -U gridfire :results silent :exports code
CREATE SCHEMA weather;
#+end_src

Then we can use the following script to import weather rasters into
our database given the schema and username as inputs.

*Note:* This script needs to be run in the same folder as where this
rasters resides. The filename of these rasters should match the
elements in the for loop (i.e. tmpf_to_sample.tif)

#+name: raster2pgsql-import-weather-rasters
#+begin_src sh :results silent :exports code :tangle ../resources/import_weather_rasters.sh :padline no :no-expand :comments link
#!/bin/sh

USERNAME=$1
SCHEMA=$2
SRID=$3
TILING=$4

echo $4

for LAYER in tmpf wd ws rh
do
    if [ -z "$4" ]
    then
        raster2pgsql -I -C -t auto -s $SRID ${LAYER}_to_sample.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME
    else
        raster2pgsql -I -C -t $TILING -s $SRID ${LAYER}_to_sample.tif $SCHEMA.$LAYER | psql -h localhost -U $USERNAME

    fi
done
#+end_src

To run the script, give it the username, schema name, and srid we wish the layers to have.

#+begin_src bash
sh import_weather_rasters.sh gridfire weather 90014
#+end_src

You may optionally include a fourth argument to set the tiling (defaults to auto).

#+begin_src bash
sh import_weather_rasters.sh gridfire weather 90014 800x800
#+end_src

* Fire Spread Model

GridFire implements the following fire behavior formulas from the fire
science literature:

- Surface Fire Spread: Rothermel 1972 with FIREMODS adjustments from Albini 1976
- Crown Fire Initiation: Van Wagner 1977
- Passive/Active Crown Fire Spread: Cruz 2005
- Flame Length and Fire Line Intensity: Byram 1959
- Midflame Wind Adjustment Factor: Albini & Baughman 1979 parameterized as in BehavePlus, FARSITE, FlamMap, FSPro, and FPA according to Andrews 2012\nocite{Albini1979,Andrews2012}
- Fire Spread on a Raster Grid: Morais 2001 (method of adaptive timesteps and fractional distances)

The following fuel models are supported:

- Anderson 13: no dynamic loading
- Scott & Burgan 40: dynamic loading implemented according to Scott & Burgan 2005

The method used to translate linear fire spread rates to a
2-dimensional raster grid were originally developed by Marco Morais at
UCSB as part of his HFire
system.\citep{Peterson2011,Peterson2009,Morais2001} Detailed
information about this software, including its source code and
research article references can be found here:

  http://firecenter.berkeley.edu/hfire/about.html

Outputs from GridFire include fire size (ac), fire line intensity
(Btu/ft/s), flame length (ft), fire volume (ac*ft), fire shape (ac/ft)
and conditional burn probability (times burned/fires initiated). Fire
line intensity and flame length may both be exported as either average
values per fire or as maps of the individual values per burned cell.

In the following sections, we describe the operation of this system in
detail.

** Fuel Model Definitions

All fires ignite and travel through some form of burnable fuel.
Although the effects of wind and slope on the rate of fire spread can
be quite pronounced, its fundamental thermodynamic characteristics are
largely determined by the fuel type in which it is sustained. For
wildfires, these fuels are predominantly herbaceous and woody
vegetation (both alive and dead) as well as decomposing elements of
dead vegetation, such as duff or leaf litter. To estimate the heat
output and rate of spread of a fire burning through any of these
fuels, we must determine those physical properties that affect heat
absorption and release.

Of course, measuring these fuel properties for every kind of
vegetation that may be burned in a wildfire is an intractable task. To
cope with this, fuels are classified into categories called ``fuel
models'' which share similar burning characteristics. Each fuel model
is then assigned a set of representative values for each of the
thermally relevant physical properties shown in Table
[[tab:fuel-model-properties]].

#+NAME: tab:fuel-model-properties
#+CAPTION: Physical properties assigned to each fuel model
#+ATTR_LATEX: :align |l|l|l| :font \small
|----------+--------------------------------------------+-----------------------------------------|
| Property | Description                                | Units                                   |
|----------+--------------------------------------------+-----------------------------------------|
| \delta   | fuel depth                                 | ft                                      |
| w_{o}    | ovendry fuel loading                       | lb/ft^{2}                               |
| \sigma   | fuel particle surface-area-to-volume ratio | ft^{2}/ft^{3}                           |
| M_{x}    | moisture content of extinction             | lb moisture/lb ovendry wood             |
| h        | fuel particle low heat content             | Btu/lb                                  |
| \rho_{p} | ovendry particle density                   | lb/ft^{3}                               |
| S_{T}    | fuel particle total mineral content        | lb minerals/lb ovendry wood             |
| S_{e}    | fuel particle effective mineral content    | lb silica-free minerals/lb ovendry wood |
| M_{f}    | fuel particle moisture content             | lb moisture/lb ovendry wood             |
|----------+--------------------------------------------+-----------------------------------------|

*Note:* While M_{f} is not, in fact, directly assigned to any of these
fuel models, their definitions remain incomplete for the purposes of
fire spread modelling (particularly those reliant on the curing
formulas of dynamic fuel loading) until it is provided as a
characteristic of local weather conditions.

The fuel models supported by GridFire include the standard 13 fuel
models of Rothermel, Albini, and Anderson\citep{Anderson1982} and the
additional 40 fuel models defined by Scott and
Burgan\citep{Scott2005}. These are all concisely encoded in an
internal data structure, which may be updated to include additional
custom fuel models desired by the user.

#+name: fuel-model-definitions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :padline no :no-expand :comments link
(ns gridfire.fuel-models)

(def fuel-models
  "Lookup table including one entry for each of the Anderson 13 and
   Scott & Burgan 40 fuel models. The fields have the following
   meanings:
   {number
    [name delta M_x-dead h
     [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr w_o-live-herbaceous w_o-live-woody]
     [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr sigma-live-herbaceous sigma-live-woody]]
   }"
  {
   ;; Grass and Grass-dominated (short-grass,timber-grass-and-understory,tall-grass)
   1   [:R01 1.0 12 8 [0.0340 0.0000 0.0000 0.0000 0.0000] [3500.0   0.0  0.0    0.0    0.0]]
   2   [:R02 1.0 15 8 [0.0920 0.0460 0.0230 0.0230 0.0000] [3000.0 109.0 30.0 1500.0    0.0]]
   3   [:R03 2.5 25 8 [0.1380 0.0000 0.0000 0.0000 0.0000] [1500.0   0.0  0.0    0.0    0.0]]
   ;; Chaparral and Shrubfields (chaparral,brush,dormant-brush-hardwood-slash,southern-rough)
   4   [:R04 6.0 20 8 [0.2300 0.1840 0.0920 0.2300 0.0000] [2000.0 109.0 30.0 1500.0    0.0]]
   5   [:R05 2.0 20 8 [0.0460 0.0230 0.0000 0.0920 0.0000] [2000.0 109.0  0.0 1500.0    0.0]]
   6   [:R06 2.5 25 8 [0.0690 0.1150 0.0920 0.0000 0.0000] [1750.0 109.0 30.0    0.0    0.0]]
   7   [:R07 2.5 40 8 [0.0520 0.0860 0.0690 0.0170 0.0000] [1750.0 109.0 30.0 1550.0    0.0]]
   ;; Timber Litter (closed-timber-litter,hardwood-litter,timber-litter-and-understory)
   8   [:R08 0.2 30 8 [0.0690 0.0460 0.1150 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   9   [:R09 0.2 25 8 [0.1340 0.0190 0.0070 0.0000 0.0000] [2500.0 109.0 30.0    0.0    0.0]]
   10  [:R10 1.0 25 8 [0.1380 0.0920 0.2300 0.0920 0.0000] [2000.0 109.0 30.0 1500.0    0.0]]
   ;; Logging Slash (light-logging-slash,medium-logging-slash,heavy-logging-slash)
   11  [:R11 1.0 15 8 [0.0690 0.2070 0.2530 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   12  [:R12 2.3 20 8 [0.1840 0.6440 0.7590 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   13  [:R13 3.0 25 8 [0.3220 1.0580 1.2880 0.0000 0.0000] [1500.0 109.0 30.0    0.0    0.0]]
   ;; Nonburnable (NB)
   91  [:NB1 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   92  [:NB2 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   93  [:NB3 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   98  [:NB4 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   99  [:NB5 0.0  0 0 [0.0000 0.0000 0.0000 0.0000 0.0000] [   0.0   0.0  0.0    0.0    0.0]]
   ;; Grass (GR)
   101 [:GR1 0.4 15 8 [0.0046 0.0000 0.0000 0.0138 0.0000] [2200.0 109.0 30.0 2000.0    0.0]]
   102 [:GR2 1.0 15 8 [0.0046 0.0000 0.0000 0.0459 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   103 [:GR3 2.0 30 8 [0.0046 0.0184 0.0000 0.0689 0.0000] [1500.0 109.0 30.0 1300.0    0.0]]
   104 [:GR4 2.0 15 8 [0.0115 0.0000 0.0000 0.0872 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   105 [:GR5 1.5 40 8 [0.0184 0.0000 0.0000 0.1148 0.0000] [1800.0 109.0 30.0 1600.0    0.0]]
   106 [:GR6 1.5 40 9 [0.0046 0.0000 0.0000 0.1561 0.0000] [2200.0 109.0 30.0 2000.0    0.0]]
   107 [:GR7 3.0 15 8 [0.0459 0.0000 0.0000 0.2479 0.0000] [2000.0 109.0 30.0 1800.0    0.0]]
   108 [:GR8 4.0 30 8 [0.0230 0.0459 0.0000 0.3352 0.0000] [1500.0 109.0 30.0 1300.0    0.0]]
   109 [:GR9 5.0 40 8 [0.0459 0.0459 0.0000 0.4132 0.0000] [1800.0 109.0 30.0 1600.0    0.0]]
   ;; Grass-Shrub (GS)
   121 [:GS1 0.9 15 8 [0.0092 0.0000 0.0000 0.0230 0.0298] [2000.0 109.0 30.0 1800.0 1800.0]]
   122 [:GS2 1.5 15 8 [0.0230 0.0230 0.0000 0.0275 0.0459] [2000.0 109.0 30.0 1800.0 1800.0]]
   123 [:GS3 1.8 40 8 [0.0138 0.0115 0.0000 0.0666 0.0574] [1800.0 109.0 30.0 1600.0 1600.0]]
   124 [:GS4 2.1 40 8 [0.0872 0.0138 0.0046 0.1561 0.3260] [1800.0 109.0 30.0 1600.0 1600.0]]
   ;; Shrub (SH)
   141 [:SH1 1.0 15 8 [0.0115 0.0115 0.0000 0.0069 0.0597] [2000.0 109.0 30.0 1800.0 1600.0]]
   142 [:SH2 1.0 15 8 [0.0620 0.1102 0.0344 0.0000 0.1768] [2000.0 109.0 30.0    0.0 1600.0]]
   143 [:SH3 2.4 40 8 [0.0207 0.1377 0.0000 0.0000 0.2847] [1600.0 109.0 30.0    0.0 1400.0]]
   144 [:SH4 3.0 30 8 [0.0390 0.0528 0.0092 0.0000 0.1171] [2000.0 109.0 30.0 1800.0 1600.0]]
   145 [:SH5 6.0 15 8 [0.1653 0.0964 0.0000 0.0000 0.1331] [ 750.0 109.0 30.0    0.0 1600.0]]
   146 [:SH6 2.0 30 8 [0.1331 0.0666 0.0000 0.0000 0.0643] [ 750.0 109.0 30.0    0.0 1600.0]]
   147 [:SH7 6.0 15 8 [0.1607 0.2433 0.1010 0.0000 0.1561] [ 750.0 109.0 30.0    0.0 1600.0]]
   148 [:SH8 3.0 40 8 [0.0941 0.1561 0.0390 0.0000 0.1997] [ 750.0 109.0 30.0    0.0 1600.0]]
   149 [:SH9 4.4 40 8 [0.2066 0.1125 0.0000 0.0712 0.3214] [ 750.0 109.0 30.0 1800.0 1500.0]]
   ;; Timber-Understory (TU)
   161 [:TU1 0.6 20 8 [0.0092 0.0413 0.0689 0.0092 0.0413] [2000.0 109.0 30.0 1800.0 1600.0]]
   162 [:TU2 1.0 30 8 [0.0436 0.0826 0.0574 0.0000 0.0092] [2000.0 109.0 30.0    0.0 1600.0]]
   163 [:TU3 1.3 30 8 [0.0505 0.0069 0.0115 0.0298 0.0505] [1800.0 109.0 30.0 1600.0 1400.0]]
   164 [:TU4 0.5 12 8 [0.2066 0.0000 0.0000 0.0000 0.0918] [2300.0 109.0 30.0    0.0 2000.0]]
   165 [:TU5 1.0 25 8 [0.1837 0.1837 0.1377 0.0000 0.1377] [1500.0 109.0 30.0    0.0  750.0]]
   ;; Timber Litter (TL)
   181 [:TL1 0.2 30 8 [0.0459 0.1010 0.1653 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   182 [:TL2 0.2 25 8 [0.0643 0.1056 0.1010 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   183 [:TL3 0.3 20 8 [0.0230 0.1010 0.1286 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   184 [:TL4 0.4 25 8 [0.0230 0.0689 0.1928 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   185 [:TL5 0.6 25 8 [0.0528 0.1148 0.2020 0.0000 0.0000] [2000.0 109.0 30.0    0.0 1600.0]]
   186 [:TL6 0.3 25 8 [0.1102 0.0551 0.0551 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   187 [:TL7 0.4 25 8 [0.0138 0.0643 0.3719 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   188 [:TL8 0.3 35 8 [0.2663 0.0643 0.0505 0.0000 0.0000] [1800.0 109.0 30.0    0.0    0.0]]
   189 [:TL9 0.6 35 8 [0.3053 0.1515 0.1905 0.0000 0.0000] [1800.0 109.0 30.0    0.0 1600.0]]
   ;; Slash-Blowdown (SB)
   201 [:SB1 1.0 25 8 [0.0689 0.1377 0.5051 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   202 [:SB2 1.0 25 8 [0.2066 0.1951 0.1837 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   203 [:SB3 1.2 25 8 [0.2525 0.1263 0.1377 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   204 [:SB4 2.7 25 8 [0.2410 0.1607 0.2410 0.0000 0.0000] [2000.0 109.0 30.0    0.0    0.0]]
   })
#+end_src

Once fuel moisture is added to the base fuel model definitions, they
will each contain values for the following six fuel size classes:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. Dead 1 hour ($<$ 1/4" diameter)
2. Dead 10 hour (1/4"--1" diameter)
3. Dead 100 hour (1"--3" diameter)
4. Dead herbaceous (dynamic fuel models only)
5. Live herbaceous
6. Live woody

In order to more easily encode mathematical operations over these size
classes, we define a collection of utility functions that will later
be used in both the fuel moisture and fire spread algorithms.

#+name: fuel-category-and-size-class-functions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn map-category [f]
  {:dead (f :dead) :live (f :live)})

(defn map-size-class [f]
  {:dead {:1hr        (f :dead :1hr)
          :10hr       (f :dead :10hr)
          :100hr      (f :dead :100hr)
          :herbaceous (f :dead :herbaceous)}
   :live {:herbaceous (f :live :herbaceous)
          :woody      (f :live :woody)}})

(defn category-sum [f]
  (+ (f :dead) (f :live)))

(defn size-class-sum [f]
  {:dead (+ (f :dead :1hr) (f :dead :10hr) (f :dead :100hr) (f :dead :herbaceous))
   :live (+ (f :live :herbaceous) (f :live :woody))})
#+end_src

Using these new size class processing functions, we can translate the
encoded fuel model definitions into human-readable representations of
the fuel model properties.

#+name: fuel-model-constructor-functions
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn build-fuel-model
  [fuel-model-number]
  (let [[name delta M_x-dead h
         [w_o-dead-1hr w_o-dead-10hr w_o-dead-100hr
          w_o-live-herbaceous w_o-live-woody]
         [sigma-dead-1hr sigma-dead-10hr sigma-dead-100hr
          sigma-live-herbaceous sigma-live-woody]]
        (fuel-models fuel-model-number)
        M_x-dead (* M_x-dead 0.01)
        h        (* h 1000.0)]
    {:name   name
     :number fuel-model-number
     :delta  delta
     :M_x    {:dead {:1hr        M_x-dead
                     :10hr       M_x-dead
                     :100hr      M_x-dead
                     :herbaceous 0.0}
              :live {:herbaceous 0.0
                     :woody      0.0}}
     :w_o    {:dead {:1hr        w_o-dead-1hr
                     :10hr       w_o-dead-10hr
                     :100hr      w_o-dead-100hr
                     :herbaceous 0.0}
              :live {:herbaceous w_o-live-herbaceous
                     :woody      w_o-live-woody}}
     :sigma  {:dead {:1hr        sigma-dead-1hr
                     :10hr       sigma-dead-10hr
                     :100hr      sigma-dead-100hr
                     :herbaceous 0.0}
              :live {:herbaceous sigma-live-herbaceous
                     :woody      sigma-live-woody}}
     :h      {:dead {:1hr        h
                     :10hr       h
                     :100hr      h
                     :herbaceous h}
              :live {:herbaceous h
                     :woody      h}}
     :rho_p  {:dead {:1hr        32.0
                     :10hr       32.0
                     :100hr      32.0
                     :herbaceous 32.0}
              :live {:herbaceous 32.0
                     :woody      32.0}}
     :S_T    {:dead {:1hr        0.0555
                     :10hr       0.0555
                     :100hr      0.0555
                     :herbaceous 0.0555}
              :live {:herbaceous 0.0555
                     :woody      0.0555}}
     :S_e    {:dead {:1hr        0.01
                     :10hr       0.01
                     :100hr      0.01
                     :herbaceous 0.01}
              :live {:herbaceous 0.01
                     :woody      0.01}}}))
#+end_src

Although most fuel model properties are static with respect to
environmental conditions, the fuel moisture content can have two
significant impacts on a fuel model's burning potential:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. Dynamic fuel loading
2. Live moisture of extinction

These two topics are discussed in the remainder of this section.

*** Dynamic Fuel Loading

All of the Scott & Burgan 40 fuel models with a live herbaceous
component are considered dynamic. In these models, a fraction of the
live herbaceous load is transferred to a new dead herbaceous category
as a function of live herbaceous moisture content (see equation
below).\citep{Burgan1979} The dead herbaceous category uses the dead 1
hour moisture content, dead moisture of extinction, and live
herbaceous surface-area-to-volume-ratio. In the following formula,
$M_{f}^{lh}$ is the live herbaceous moisture content.

\begin{align*}
  \textrm{FractionGreen} &= \left\{
    \begin{array}{lr}
      0 & M_{f}^{lh} \le 0.3 \\
      1 & M_{f}^{lh} \ge 1.2 \\
      \frac{M_{f}^{lh}}{0.9} - \frac{1}{3} & \textrm{else}
    \end{array}
  \right. \\
  \textrm{FractionCured} &= 1 - \textrm{FractionGreen}
\end{align*}

#+name: add-dynamic-fuel-loading
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-dynamic-fuel-loading
  [{:keys [number M_x M_f w_o sigma] :as fuel-model}]
  (let [live-herbaceous-load (-> w_o :live :herbaceous)]
    (if (and (> number 100) (pos? live-herbaceous-load))
      ;; dynamic fuel model
      (let [fraction-green (max 0.0 (min 1.0 (- (/ (-> M_f :live :herbaceous) 0.9) 1/3)))
            fraction-cured (- 1.0 fraction-green)]
        (-> fuel-model
            (assoc-in [:M_f   :dead :herbaceous] (-> M_f :dead :1hr))
            (assoc-in [:M_x   :dead :herbaceous] (-> M_x :dead :1hr))
            (assoc-in [:w_o   :dead :herbaceous] (* live-herbaceous-load fraction-cured))
            (assoc-in [:w_o   :live :herbaceous] (* live-herbaceous-load fraction-green))
            (assoc-in [:sigma :dead :herbaceous] (-> sigma :live :herbaceous))))
      ;; static fuel model
      fuel-model)))
#+end_src

Once the dynamic fuel loading is applied, we can compute the size
class weighting factors expressed in equations 53-57 in Rothermel
1972\citep{Rothermel1972}. For brevity, these formulas are elided from
this text.

#+name: add-weighting-factors
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-weighting-factors
  [{:keys [w_o sigma rho_p] :as fuel-model}]
  (let [A_ij (map-size-class (fn [i j] (/ (* (-> sigma i j) (-> w_o i j))
                                          (-> rho_p i j))))

        A_i  (size-class-sum (fn [i j] (-> A_ij i j)))

        A_T  (category-sum (fn [i] (-> A_i i)))

        f_ij (map-size-class (fn [i j] (if (pos? (-> A_i i))
                                         (/ (-> A_ij i j)
                                            (-> A_i i))
                                         0.0)))

        f_i  (map-category (fn [i] (if (pos? A_T)
                                     (/ (-> A_i i) A_T)
                                     0.0)))

        firemod-size-classes (map-size-class
                              (fn [i j] (condp <= (-> sigma i j)
                                          1200 1
                                          192  2
                                          96   3
                                          48   4
                                          16   5
                                          0    6)))

        firemod-weights (into {}
                              (for [[category size-classes] firemod-size-classes]
                                [category
                                 (apply merge-with +
                                        (for [[size-class firemod-size-class] size-classes]
                                          {firemod-size-class (get-in f_ij [category size-class])}))]))

        g_ij (map-size-class (fn [i j]
                               (let [firemod-size-class (-> firemod-size-classes i j)]
                                 (get-in firemod-weights [i firemod-size-class]))))]
    (-> fuel-model
        (assoc :f_ij f_ij)
        (assoc :f_i  f_i)
        (assoc :g_ij g_ij))))
#+end_src

*** Live Moisture of Extinction

The live moisture of extinction for each fuel model is determined from
the dead fuel moisture content, the dead moisture of extinction, and
the ratio of dead fuel loading to live fuel loading using Equation 88
from Rothermel 1972, adjusted according to Albini 1976 Appendix III to
match the behavior of Albini's original FIREMODS
library.\citep{Rothermel1972,Albini1976} Whenever the fuel moisture
content becomes greater than or equal to the moisture of extinction, a
fire will no longer spread through that fuel. Here are the formulas
referenced above:

\begin{align*}
  M_{x}^{l} &= \max(M_{x}^{d}, 2.9 \, W' \, (1 - \frac{M_{f}^{d}}{M_{x}^{d}}) - 0.226) \\
  W' &= \frac{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in L}{w_{o}^{c} \> e^{-500/\sigma^{c}}}} \\
  M_{f}^{d} &= \frac{\sum_{c \in D}{w_{o}^{c} \> M_{f}^{c} \> e^{-138/\sigma^{c}}}}{\sum_{c \in D}{w_{o}^{c} \> e^{-138/\sigma^{c}}}}
\end{align*}

where $M_{x}^{l}$ is the live moisture of extinction, $M_{x}^{d}$ is
the dead moisture of extinction, $D$ is the set of dead fuel size
classes (1hr, 10hr, 100hr, herbaceous), $L$ is the set of live fuel
size classes (herbaceous, woody), $w_{o}^{c}$ is the dry weight
loading of size class $c$, $\sigma^{c}$ is the surface area to volume
ratio of size class $c$, and $M_{f}^{c}$ is the moisture content of
size class $c$.

#+name: add-live-moisture-of-extinction
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fuel_models.clj :no-expand :comments link
(defn add-live-moisture-of-extinction
  "Equation 88 from Rothermel 1972 adjusted by Albini 1976 Appendix III."
  [{:keys [w_o sigma M_f M_x] :as fuel-model}]
  (let [dead-loading-factor  (:dead (size-class-sum
                                     (fn [i j] (if (pos? (-> sigma i j))
                                                 (* (-> w_o i j)
                                                    (Math/exp (/ -138.0 (-> sigma i j))))
                                                 0.0))))
        live-loading-factor  (:live (size-class-sum
                                     (fn [i j] (if (pos? (-> sigma i j))
                                                 (* (-> w_o i j)
                                                    (Math/exp (/ -500.0 (-> sigma i j))))
                                                 0.0))))
        dead-moisture-factor (:dead (size-class-sum
                                     (fn [i j] (if (pos? (-> sigma i j))
                                                 (* (-> w_o i j)
                                                    (Math/exp (/ -138.0 (-> sigma i j)))
                                                    (-> M_f i j))
                                                 0.0))))
        dead-to-live-ratio   (if (pos? live-loading-factor)
                               (/ dead-loading-factor live-loading-factor))
        dead-fuel-moisture   (if (pos? dead-loading-factor)
                               (/ dead-moisture-factor dead-loading-factor)
                               0.0)
        M_x-dead             (-> M_x :dead :1hr)
        M_x-live             (if (pos? live-loading-factor)
                               (max M_x-dead
                                    (- (* 2.9
                                          dead-to-live-ratio
                                          (- 1.0 (/ dead-fuel-moisture M_x-dead)))
                                       0.226))
                               M_x-dead)]
    (-> fuel-model
        (assoc-in [:M_x :live :herbaceous] M_x-live)
        (assoc-in [:M_x :live :woody]      M_x-live))))

(defn moisturize
  [fuel-model fuel-moisture]
  (-> fuel-model
      (assoc :M_f fuel-moisture)
      (assoc-in [:M_f :dead :herbaceous] 0.0)
      (add-dynamic-fuel-loading)
      (add-weighting-factors)
      (add-live-moisture-of-extinction)))
#+end_src

This concludes our coverage of fuel models and and fuel moisture.

** Surface Fire Formulas

To simulate fire behavior in as similar a way as possible to the US
government-sponsored fire models (e.g., FARSITE, FlamMap, FPA,
BehavePlus), we adopt the surface fire spread and reaction intensity
formulas from Rothermel's 1972 publication ``A Mathematical Model for
Predicting Fire Spread in Wildland Fuels''.\citep{Rothermel1972}

Very briefly, the surface rate of spread of a fire's leading edge $R$
is described by the following formula:

\begin{displaymath}
R = \frac{I_{R} \, \xi \, (1 + \phi_{W} + \phi_{S})}{\rho_{b} \, \epsilon \, Q_{ig}}
\end{displaymath}

where these terms have the meanings shown in Table
[[tab:fire-spread-inputs]].

#+NAME: tab:fire-spread-inputs
#+CAPTION: Inputs to Rothermel's surface fire rate of spread equation
#+ATTR_LATEX: :align |l|l| :font \small
|----------+--------------------------------|
| Term     | Meaning                        |
|----------+--------------------------------|
| R        | surface fire spread rate       |
| I_{R}    | reaction intensity             |
| \xi      | propagating flux ratio         |
| \phi_{W} | wind coefficient               |
| \phi_{S} | slope factor                   |
| \rho_{b} | oven-dry fuel bed bulk density |
| \epsilon | effective heating number       |
| Q_{ig}   | heat of preignition            |
|----------+--------------------------------|

For a full description of each of the subcomponents of Rothermel's
surface fire spread rate equation, see the Rothermel 1972 reference
above. In addition to applying the base Rothermel equations, GridFire
reduces the spread rates for all of the Scott & Burgan 40 fuel models
of the grass subgroup (101-109) by 50%. This addition was originally
suggested by Chris Lautenberger of REAX Engineering.

For efficiency, the surface fire spread equation given above is
computed first without introducing the effects of wind and slope
($\phi_{W} = \phi_{S} = 0$).

#+name: rothermel-surface-fire-spread-no-wind-no-slope
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :padline no :no-expand :comments link
(ns gridfire.surface-fire
  (:require [gridfire.fuel-models :refer [map-category map-size-class
                                          category-sum size-class-sum]]))

(def grass-fuel-model? #(and (> % 100) (< % 110)))

(defn rothermel-surface-fire-spread-no-wind-no-slope
  "Returns the rate of surface fire spread in ft/min and the reaction
   intensity (i.e., amount of heat output) of a fire in Btu/ft^2*min
   given a map containing these keys:
   - number [fuel model number]
   - delta [fuel depth (ft)]
   - w_o [ovendry fuel loading (lb/ft^2)]
   - sigma [fuel particle surface-area-to-volume ratio (ft^2/ft^3)]
   - h [fuel particle low heat content (Btu/lb)]
   - rho_p [ovendry particle density (lb/ft^3)]
   - S_T [fuel particle total mineral content (lb minerals/lb ovendry wood)]
   - S_e [fuel particle effective mineral content (lb silica-free minerals/lb ovendry wood)]
   - M_x [moisture content of extinction (lb moisture/lb ovendry wood)]
   - M_f [fuel particle moisture content (lb moisture/lb ovendry wood)]
   - f_ij [percent of load per size class (%)]
   - f_i [percent of load per category (%)]
   - g_ij [percent of load per size class from Albini_1976_FIREMOD, page 20]"
  [{:keys [number delta w_o sigma h rho_p S_T S_e M_x M_f f_ij f_i g_ij] :as fuel-model}]
  (let [S_e_i      (size-class-sum (fn [i j] (* (-> f_ij i j) (-> S_e i j))))

        ;; Mineral damping coefficient
        eta_S_i    (map-category (fn [i] (let [S_e_i (-> S_e_i i)]
                                           (if (pos? S_e_i)
                                             (/ 0.174 (Math/pow S_e_i 0.19))
                                             1.0))))

        M_f_i      (size-class-sum (fn [i j] (* (-> f_ij i j) (-> M_f i j))))

        M_x_i      (size-class-sum (fn [i j] (* (-> f_ij i j) (-> M_x i j))))

        r_M_i      (map-category (fn [i] (let [M_f (-> M_f_i i)
                                               M_x (-> M_x_i i)]
                                           (if (pos? M_x)
                                             (min 1.0 (/ M_f M_x))
                                             1.0))))

        ;; Moisture damping coefficient
        eta_M_i    (map-category (fn [i] (+ 1.0
                                            (* -2.59 (-> r_M_i i))
                                            (* 5.11 (Math/pow (-> r_M_i i) 2))
                                            (* -3.52 (Math/pow (-> r_M_i i) 3)))))

        h_i        (size-class-sum (fn [i j] (* (-> f_ij i j) (-> h i j))))

        ;; Net fuel loading (lb/ft^2)
        W_n_i      (size-class-sum (fn [i j] (* (-> g_ij i j)
                                                (-> w_o i j)
                                                (- 1.0 (-> S_T i j)))))

        beta_i     (size-class-sum (fn [i j] (/ (-> w_o i j) (-> rho_p i j))))

        ;; Packing ratio
        beta       (if (pos? delta)
                     (/ (category-sum (fn [i] (-> beta_i i))) delta)
                     0.0)

        sigma'_i   (size-class-sum (fn [i j] (* (-> f_ij i j) (-> sigma i j))))

        sigma'     (category-sum (fn [i] (* (-> f_i i) (-> sigma'_i i))))

        ;; Optimum packing ratio
        beta_op    (if (pos? sigma')
                     (/ 3.348 (Math/pow sigma' 0.8189))
                     1.0)

        ;; Albini 1976 replaces (/ 1 (- (* 4.774 (Math/pow sigma' 0.1)) 7.27))
        A          (if (pos? sigma')
                     (/ 133.0 (Math/pow sigma' 0.7913))
                     0.0)

        ;; Maximum reaction velocity (1/min)
        Gamma'_max (/ (Math/pow sigma' 1.5)
                      (+ 495.0 (* 0.0594 (Math/pow sigma' 1.5))))

        ;; Optimum reaction velocity (1/min)
        Gamma'     (* Gamma'_max
                      (Math/pow (/ beta beta_op) A)
                      (Math/exp (* A (- 1.0 (/ beta beta_op)))))

        ;; Reaction intensity (Btu/ft^2*min)
        I_R        (* Gamma' (category-sum (fn [i] (* (W_n_i i) (h_i i)
                                                      (eta_M_i i) (eta_S_i i)))))

        ;; Propagating flux ratio
        xi         (/ (Math/exp (* (+ 0.792 (* 0.681 (Math/pow sigma' 0.5)))
                                   (+ beta 0.1)))
                      (+ 192.0 (* 0.2595 sigma')))

        E          (* 0.715 (Math/exp (* -3.59 (/ sigma' 10000.0))))

        B          (* 0.02526 (Math/pow sigma' 0.54))

        C          (* 7.47 (Math/exp (* -0.133 (Math/pow sigma' 0.55))))

        ;; Derive wind factor
        get-phi_W  (fn [midflame-wind-speed]
                     (if (and (pos? beta) (pos? midflame-wind-speed))
                       (-> midflame-wind-speed
                           (Math/pow B)
                           (* C)
                           (/ (Math/pow (/ beta beta_op) E)))
                       0.0))

        ;; Derive wind speed from wind factor
        get-wind-speed (fn [phi_W]
                         (-> phi_W
                             (* (Math/pow (/ beta beta_op) E))
                             (/ C)
                             (Math/pow (/ 1.0 B))))

        ;; Derive slope factor
        get-phi_S  (fn [slope]
                     (if (and (pos? beta) (pos? slope))
                       (* 5.275 (Math/pow beta -0.3) (Math/pow slope 2.0))
                       0.0))

        ;; Heat of preignition (Btu/lb)
        Q_ig       (map-size-class (fn [i j] (+ 250.0 (* 1116.0 (-> M_f i j)))))

        foo_i      (size-class-sum (fn [i j] (let [sigma_ij (-> sigma i j)
                                                   Q_ig_ij  (-> Q_ig  i j)]
                                               (if (pos? sigma_ij)
                                                 (* (-> f_ij i j)
                                                    (Math/exp (/ -138 sigma_ij))
                                                    Q_ig_ij)
                                                 0.0))))

        rho_b_i    (size-class-sum (fn [i j] (-> w_o i j)))

        ;; Ovendry bulk density (lb/ft^3)
        rho_b      (if (pos? delta)
                     (/ (category-sum (fn [i] (-> rho_b_i i))) delta)
                     0.0)

        rho_b-epsilon-Q_ig (* rho_b (category-sum (fn [i] (* (-> f_i i) (-> foo_i i)))))

        ;; Surface fire spread rate (ft/min)
        R          (if (pos? rho_b-epsilon-Q_ig)
                     (/ (* I_R xi) rho_b-epsilon-Q_ig)
                     0.0)

        ;; Addition proposed by Chris Lautenberger (REAX 2015)
        spread-rate-multiplier (if (grass-fuel-model? number) 0.5 1.0)]

    {:spread-rate        (* R spread-rate-multiplier)
     :reaction-intensity I_R
     :residence-time     (/ 384.0 sigma')
     :get-phi_W          get-phi_W
     :get-phi_S          get-phi_S
     :get-wind-speed     get-wind-speed}))
#+end_src

Later, this no-wind-no-slope value is used to compute the maximum
spread rate and direction for the leading edge of the surface fire
under analysis. Since Rothermel's original equations assume that the
wind direction and slope are aligned, the effects of cross-slope winds
must be taken into effect. Like Morais' HFire system, GridFire implements
the vector addition procedure defined in Rothermel 1983 that combines
the wind-only and slope-only spread rates independently to calculate
the effective fire spread direction and
magnitude.\citep{Peterson2011,Peterson2009,Morais2001,Rothermel1983}

A minor wrinkle is introduced when putting these calculations into
practice because Rothermel's formulas all expect a measure of midflame
wind speed. However, wind speed data is often collected at a height 20
feet above either unsheltered ground or a tree canopy layer if
present. To convert this 20-ft wind speed to the required midflame
wind speed value, GridFire uses the *wind adjustment factor* formula
from Albini & Baughman 1979, parameterized as in BehavePlus, FARSITE,
FlamMap, FSPro, and FPA according to Andrews
2012\citep{Albini1979,Andrews2012}. This formula is shown below:

\begin{displaymath}
  WAF &= \left\{
    \begin{array}{lr}
      \frac{1.83}{ \ln(\frac{20.0 + 0.36 FBD}{0.13 FBD}) } & CC = 0 \\
      \frac{0.555}{ \sqrt(CH (CC/300.0)) \ln(\frac{20 + 0.36 CH}{0.13 CH}) } & CC > 0
    \end{array}
  \right.
\end{displaymath}

where WAF is the unitless wind adjustment factor, FBD is the fuel bed
depth in feet, CH is the canopy height in ft, and CC is the canopy
cover percentage (0-100).

#+name: wind-adjustment-factor
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn wind-adjustment-factor
  "ft ft 0-100"
  [fuel-bed-depth canopy-height canopy-cover]
  (cond
    ;; sheltered: equation 2 based on CC and CH, CR=1 (Andrews 2012)
    (and (pos? canopy-cover)
         (pos? canopy-height))
    (/ 0.555 (* (Math/sqrt (* (/ canopy-cover 300.0) canopy-height))
                (Math/log (/ (+ 20.0 (* 0.36 canopy-height)) (* 0.13 canopy-height)))))

    ;; unsheltered: equation 6 H_F = H (Andrews 2012)
    (pos? fuel-bed-depth)
    (/ 1.83 (Math/log (/ (+ 20.0 (* 0.36 fuel-bed-depth)) (* 0.13 fuel-bed-depth))))

    ;; non-burnable fuel model
    :otherwise
    0.0))

(defn wind-adjustment-factor-elmfire
  "ft m 0-1"
  [fuel-bed-depth canopy-height canopy-cover]
  (cond
    ;; sheltered WAF
    (and (pos? canopy-cover)
         (pos? canopy-height))
    (* (/ 1.0 (Math/log (/ (+ 20.0 (* 0.36 (/ canopy-height 0.3048)))
                           (* 0.13 (/ canopy-height 0.3048)))))
       (/ 0.555 (Math/sqrt (* (/ canopy-cover 3.0) (/ canopy-height 0.3048)))))

    ;; unsheltered WAF
    (pos? fuel-bed-depth)
    (* (/ (+ 1.0 (/ 0.36 1.0))
          (Math/log (/ (+ 20.0 (* 0.36 fuel-bed-depth))
                       (* 0.13 fuel-bed-depth))))
       (- (Math/log (/ (+ 1.0 0.36) 0.13)) 1.0))

    ;; non-burnable fuel model
    :otherwise
    0.0))
#+end_src

The midflame wind speed that would be required to produce the combined
spread rate in a no-slope scenario is termed the effective windspeed
$U_{\textrm{eff}}$. Following the recommendations given in Appendix
III of Albini 1976, these midflame wind speeds are all limited to $0.9
I_{R}$.\citep{Albini1976}

Next, the effective wind speed is used to compute the length to width
ratio $\frac{L}{W}$ of an ellipse that approximates the fire front
using equation 9 from Rothermel 1991.\citep{Rothermel1991} This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.\citep{Albini1980}
Finally, this eccentricity $E$ is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:

\begin{align*}
  \frac{L}{W} &= 1 + 0.002840909 \, U_{\textrm{eff}} \, \textrm{EAF} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align*}

where \theta is the angular offset from the direction of maximum fire
spread, R_{max} is the maximum spread rate, R_{\theta} is the spread
rate in direction \theta, and EAF is the ellipse adjustment factor, a
term introduced by Marco Morais and Seth Peterson in their HFire work
that can be increased or decreased to make the fire shape more
elliptical or circular respectively.\citep{Peterson2009}

*Note:* The coefficient 0.002840909 in the $\frac{L}{W}$ formula is in
units of min/ft. The original equation from Rothermel 1991 used 0.25
in units of hr/mi, so this was converted to match GridFire's use of
ft/min for $U_{\textrm{eff}}$.

#+name: rothermel-surface-fire-spread-max-and-any
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn almost-zero? [^double x]
  (< (Math/abs x) 0.000001))

(defn degrees-to-radians
  [degrees]
  (/ (* degrees Math/PI) 180.0))

(defn radians-to-degrees
  [radians]
  (/ (* radians 180.0) Math/PI))

(defn scale-spread-to-max-wind-speed
  [{:keys [effective-wind-speed max-spread-direction] :as spread-properties}
   spread-rate max-wind-speed phi-max]
  (if (> effective-wind-speed max-wind-speed)
    {:max-spread-rate      (* spread-rate (+ 1.0 phi-max))
     :max-spread-direction max-spread-direction
     :effective-wind-speed max-wind-speed}
    spread-properties))

(defn add-eccentricity
  [{:keys [effective-wind-speed] :as spread-properties} ellipse-adjustment-factor]
  (let [length-width-ratio (+ 1.0 (* 0.002840909
                                     effective-wind-speed
                                     ellipse-adjustment-factor))
        eccentricity       (/ (Math/sqrt (- (Math/pow length-width-ratio 2.0) 1.0))
                              length-width-ratio)]
    (assoc spread-properties :eccentricity eccentricity)))

(defn smallest-angle-between [theta1 theta2]
  (let [angle (Math/abs ^double (- theta1 theta2))]
    (if (> angle 180.0)
      (- 360.0 angle)
      angle)))

(defn rothermel-surface-fire-spread-max
  "Note: fire ellipse adjustment factor, < 1.0 = more circular, > 1.0 = more elliptical"
  [{:keys [spread-rate reaction-intensity get-phi_W get-phi_S get-wind-speed]}
   midflame-wind-speed wind-from-direction slope aspect ellipse-adjustment-factor]
  (let [phi_W             (get-phi_W midflame-wind-speed)
        phi_S             (get-phi_S slope)
        slope-direction   (mod (+ aspect 180.0) 360.0)
        wind-to-direction (mod (+ wind-from-direction 180.0) 360.0)
        max-wind-speed    (* 0.9 reaction-intensity)
        phi-max           (get-phi_W max-wind-speed)]
    (->
     (cond (and (almost-zero? midflame-wind-speed) (almost-zero? slope))
           ;; no wind, no slope
           {:max-spread-rate      spread-rate
            :max-spread-direction 0.0
            :effective-wind-speed 0.0}

           (almost-zero? slope)
           ;; wind only
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_W))
            :max-spread-direction wind-to-direction
            :effective-wind-speed midflame-wind-speed}

           (almost-zero? midflame-wind-speed)
           ;; slope only
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_S))
            :max-spread-direction slope-direction
            :effective-wind-speed (get-wind-speed phi_S)}

           (< (smallest-angle-between wind-to-direction slope-direction) 15.0)
           ;; wind blows (within 15 degrees of) upslope
           {:max-spread-rate      (* spread-rate (+ 1.0 phi_W phi_S))
            :max-spread-direction slope-direction
            :effective-wind-speed (get-wind-speed (+ phi_W phi_S))}

           :else
           ;; wind blows across slope
           (let [slope-magnitude    (* spread-rate phi_S)
                 wind-magnitude     (* spread-rate phi_W)
                 difference-angle   (degrees-to-radians
                                     (mod (- wind-to-direction slope-direction) 360.0))
                 x                  (+ slope-magnitude
                                       (* wind-magnitude (Math/cos difference-angle)))
                 y                  (* wind-magnitude (Math/sin difference-angle))
                 combined-magnitude (Math/sqrt (+ (* x x) (* y y)))]
             (if (almost-zero? combined-magnitude)
               {:max-spread-rate      spread-rate
                :max-spread-direction 0.0
                :effective-wind-speed 0.0}
               (let [max-spread-rate      (+ spread-rate combined-magnitude)
                     phi-combined         (- (/ max-spread-rate spread-rate) 1.0)
                     offset               (radians-to-degrees
                                           (Math/asin (/ (Math/abs y) combined-magnitude)))
                     offset'              (if (>= x 0.0)
                                            (if (>= y 0.0)
                                              offset
                                              (- 360.0 offset))
                                            (if (>= y 0.0)
                                              (- 180.0 offset)
                                              (+ 180.0 offset)))
                     max-spread-direction (mod (+ slope-direction offset') 360.0)
                     effective-wind-speed (get-wind-speed phi-combined)]
                 {:max-spread-rate      max-spread-rate
                  :max-spread-direction max-spread-direction
                  :effective-wind-speed effective-wind-speed}))))
     (scale-spread-to-max-wind-speed spread-rate max-wind-speed phi-max)
     (add-eccentricity ellipse-adjustment-factor))))

(defn rothermel-surface-fire-spread-any
  [{:keys [max-spread-rate max-spread-direction eccentricity]} spread-direction]
  (let [theta (smallest-angle-between max-spread-direction spread-direction)]
    (if (or (almost-zero? eccentricity) (almost-zero? theta))
      max-spread-rate
      (* max-spread-rate (/ (- 1.0 eccentricity)
                            (- 1.0 (* eccentricity
                                      (Math/cos (degrees-to-radians theta)))))))))
#+end_src

Using these surface fire spread rate and reaction intensity values, we
next calculate fire intensity values by applying Anderson's flame
depth formula and Byram's fire line intensity and flame length
equations as described below.\citep{Anderson1969,Byram1959}

\begin{align*}
  t &= \frac{384}{\sigma} \\
  D &= Rt \\
  I &= \frac{I_{R}D}{60} \\
  L &= 0.45(I)^{0.46}
\end{align*}

where $\sigma$ is the weighted sum by size class of the fuel model's
surface area to volume ratio in ft^{2}/ft^{3}, $t$ is the residence
time in minutes, $R$ is the surface fire spread rate in ft/min, $D$ is
the flame depth in ft, $I_{R}$ is the reaction intensity in
Btu/ft^{2}/min, $I$ is the fire line intensity in Btu/ft/s, and $L$ is
the flame length in ft.

#+name: surface-fire-intensity-formulas
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/surface_fire.clj :no-expand :comments link
(defn anderson-flame-depth
  "Returns the depth, or front-to-back distance, of the actively flaming zone
   of a free-spreading fire in ft given:
   - spread-rate (ft/min)
   - residence-time (min)"
  [spread-rate residence-time]
  (* spread-rate residence-time))

(defn byram-fire-line-intensity
  "Returns the rate of heat release per unit of fire edge in Btu/ft*s given:
   - reaction-intensity (Btu/ft^2*min)
   - flame-depth (ft)"
  [reaction-intensity flame-depth]
  (/ (* reaction-intensity flame-depth) 60.0))

(defn byram-flame-length
  "Returns the average flame length in ft given:
   - fire-line-intensity (Btu/ft*s)"
  [fire-line-intensity]
  (* 0.45 (Math/pow fire-line-intensity 0.46)))
#+end_src

This concludes our coverage of the surface fire behavior equations
implemented in GridFire. In Section [[Fire Spread on a Raster Grid]],
these formulas will be translated from one-dimension to
two-dimensional spread on a raster grid. Before we move on to that,
however, the following section explains how crown fire behavior
metrics are incorporated into our model.

** Crown Fire Formulas

In order to incorporate the effects of crown fire behavior, GridFire
includes the crown fire initiation routine from Van Wagner
1977.\citep{VanWagner1977} According to this approach, there are two
threshold values (/critical intensity/ and /critical spread rate/)
that must be calculated in order to determine whether a fire will
become an active or passive crown fire or simply remain a surface
fire. The formulas for these thresholds are as follows:

\begin{align*}
  H &= 460 + 2600 M^{f} \\
  I^{*} &= (0.01 \, Z_{b} \, H)^{1.5} \\
  R^{*} &= \frac{3.0}{B_{m}}
\end{align*}

where $H$ is the heat of ignition for the herbaceous material in the
canopy in kJ/kg, $M^{f}$ is the foliar moisture content in lb
moisture/lb ovendry weight, $Z_{b}$ is the canopy base height in
meters, $I^{*}$ is the critical intensity in kW/m, $B_{m}$ is the
crown bulk density in kg/m^{3}, and $R^{*}$ is the critical spread
rate in m/min.

If the canopy cover is greater than 40% and the surface fire line
intensity is greater than the critical intensity ($I > I^{*}$), then
crown fire initiation occurs.

#+name: van-wagner-crown-fire-initiation
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :padline no :no-expand :comments link
(ns gridfire.crown-fire)

(defn ft->m [ft] (* 0.3048 ft))

(defn kW-m->Btu-ft-s [kW-m] (* 0.288894658272 kW-m))

(defn van-wagner-crown-fire-initiation?
  "- canopy-cover (0-100 %)
   - canopy-base-height (ft)
   - foliar-moisture (lb moisture/lb ovendry weight)
   - fire-line-intensity (Btu/ft*s)"
  [canopy-cover canopy-base-height foliar-moisture fire-line-intensity]
  (and (> canopy-cover 40.0)
       (-> (+ 460.0 (* 2600.0 foliar-moisture)) ;; heat-of-ignition = kJ/kg
           (* 0.01 (ft->m canopy-base-height))
           (Math/pow 1.5) ;; critical-intensity = kW/m
           (kW-m->Btu-ft-s)
           (< fire-line-intensity))))
#+end_src

If crowning occurs, then the active and passive crown fire spread
rates are calculated from the formulas given in Cruz
2005.\citep{Cruz2005}

\begin{align*}
  \textrm{CROS}_{A} &= 11.02 \> U_{10m}^{0.90} \> B_{m}^{0.19} \> e^{-0.17 \, \textrm{EFFM}} \\
  \textrm{CROS}_{P} &= \textrm{CROS}_{A} \> e^{\frac{-\textrm{CROS}_{A}}{R^{*}}}
\end{align*}

where $\textrm{CROS}_{A}$ is the active crown fire spread rate in
m/min, $U_{10m}$ is the 10 meter windspeed in km/hr, $B_{m}$ is the
crown bulk density in kg/m^{3}, EFFM is the estimated fine fuel
moisture as a percent (0-100), and $\textrm{CROS}_{P}$ is the passive
crown fire spread rate in m/min.

If the active crown fire spread rate is greater than the critical
spread rate ($\textrm{CROS}_{A} > R^{*}$), then the crown fire will be
active, otherwise passive.

#+name: cruz-crown-fire-spread
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
(defn mph->km-hr [mph] (* 1.609344 mph))

(defn lb-ft3->kg-m3 [lb-ft3] (* 16.01846 lb-ft3))

(defn m->ft [m] (* 3.281 m))

(defn cruz-crown-fire-spread
  "Returns spread-rate in ft/min given:
   - wind-speed-20ft (mph)
   - crown-bulk-density (lb/ft^3)
   - estimated-fine-fuel-moisture (-> M_f :dead :1hr) (0-1)"
  [wind-speed-20ft crown-bulk-density estimated-fine-fuel-moisture]
  (let [wind-speed-10m               (/ (mph->km-hr wind-speed-20ft) 0.87) ;; km/hr
        crown-bulk-density           (lb-ft3->kg-m3 crown-bulk-density) ;; kg/m^3
        estimated-fine-fuel-moisture (* 100.0 estimated-fine-fuel-moisture)
        active-spread-rate           (* 11.02
                                        (Math/pow wind-speed-10m 0.90)
                                        (Math/pow crown-bulk-density 0.19)
                                        (Math/exp (* -0.17 estimated-fine-fuel-moisture)))
                                        ;; m/min
        critical-spread-rate         (/ 3.0 crown-bulk-density) ;; m/min
        criteria-for-active-crowning (/ active-spread-rate critical-spread-rate)]
    (m->ft
     (if (> active-spread-rate critical-spread-rate)
       active-spread-rate
       (* active-spread-rate (Math/exp (- criteria-for-active-crowning)))))))
#+end_src

Once the crown fire spread rate is determined, the crown fire line
intensity and flame lengths may be derived using the following
formulas:

\begin{align*}
  I_{c} &= \frac{R_{c} B (Z - Z_{b}) h}{60} \\
  L_{c} &= 0.45(I + I_{c})^{0.46}
\end{align*}

where $I_{c}$ is the crown fire line intensity in Btu/ft/s, $R_{c}$ is
the crown fire spread rate (either $\textrm{CROS}_{A}$ or
$\textrm{CROS}_{P}$) in ft/min, $B$ is the crown bulk density in
lb/ft^{3}, $Z$ is the canopy height in ft, $Z_{b}$ is the canopy base
height in ft, $h$ is the fuel model heat of combustion (generally 8000
Btu/lb), $L_{c}$ is the crown flame length in ft, and $I$ is the
surface fire line intensity in Btu/ft/s.

#+name: crown-fire-line-intensity
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
;; heat of combustion is h from the fuel models (generally 8000 Btu/lb)
(defn crown-fire-line-intensity
  "(ft/min * lb/ft^3 * ft * Btu/lb)/60 = (Btu/ft*min)/60 = Btu/ft*s"
  [crown-spread-rate crown-bulk-density canopy-height canopy-base-height heat-of-combustion]
  (/ (* crown-spread-rate
        crown-bulk-density
        (- canopy-height canopy-base-height)
        heat-of-combustion)
     60.0))

(defn crown-fire-line-intensity-elmfire ;; kW/m
  [surface-fire-line-intensity crown-spread-rate crown-bulk-density
   canopy-height canopy-base-height]
  (let [heat-of-combustion 18000] ;; kJ/m^2
    (+ surface-fire-line-intensity ;; kW/m
       (/ (* 0.3048 ;; m/ft
             crown-spread-rate ;; ft/min
             crown-bulk-density ;; kg/m^3
             (- canopy-height canopy-base-height) ;; m
             heat-of-combustion) ;; kJ/kg
          60.0)))) ;; s/min
#+end_src

As with surface fire spread, the wind speed (this time the 20-ft wind
speed in mph $U_{20}$) is used to compute the length to width ratio
$\frac{L}{W}$ of an ellipse that approximates the crown fire front
using equation 9 from Rothermel 1991.\citep{Rothermel1991} This length
to width ratio is then converted into an eccentricity measure of the
ellipse using equation 8 from Albini and Chase 1980.\citep{Albini1980}
Finally, this eccentricity $E$ is used to project the maximum spread
rate to any point along the fire front. Here are the formulas used:

\begin{align*}
  \frac{L}{W} &= 1 + 0.125 \, U_{20} \, \textrm{EAF} \\
  E &= \frac{\sqrt{(\frac{L}{W})^{2} - 1}}{\frac{L}{W}} \\
  R_{\theta} &= R_{\max}\left(\frac{1-E}{1-E\cos\theta}\right)
\end{align*}

where \theta is the angular offset from the direction of maximum fire
spread, R_{max} is the maximum spread rate, R_{\theta} is the spread
rate in direction \theta, and EAF is the ellipse adjustment factor, a
term introduced by Marco Morais and Seth Peterson in their HFire work
that can be increased or decreased to make the fire shape more
elliptical or circular respectively.\citep{Peterson2009}

#+name: crown-eccentricity
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/crown_fire.clj :no-expand :comments link
(defn crown-fire-eccentricity
  "mph"
  [wind-speed-20ft ellipse-adjustment-factor]
  (let [length-width-ratio (+ 1.0 (* 0.125
                                     wind-speed-20ft
                                     ellipse-adjustment-factor))]
    (/ (Math/sqrt (- (Math/pow length-width-ratio 2.0) 1.0))
       length-width-ratio)))

(defn elmfire-length-to-width-ratio
  "true/false mph int>0 ft/min
   Crown L/W = min(1.0 + 0.125*U20_mph, L/W_max)
   Surface L/W = 0.936*e^(0.2566*Ueff_mph) + 0.461*e^(-0.1548*Ueff_mph) - 0.397"
  [crown-fire? wind-speed-20ft max-length-to-width-ratio effective-wind-speed]
  (if crown-fire?
    (min (+ 1.0 (* 0.125 wind-speed-20ft)) max-length-to-width-ratio)
    (min (+ (* 0.936 (Math/exp (/ (* 0.2566 effective-wind-speed 60.0) 5280.0)))
            (* 0.461 (Math/exp (/ (* -0.1548 effective-wind-speed 60.0) 5280.0)))
            -0.397)
         8.0)))
#+end_src

This concludes our discussion of the crown fire behavior formulas used
in GridFire.

** Fire Spread on a Raster Grid

Although Rothermel's spread rate formula provides some useful insight
into how quickly a fire's leading edge may travel, it offers no
specific mechanism for simulating fire movement in two or more
dimensions. Therefore, when attempting to use the Rothermel equations
in any spatial analysis, one must begin by choosing a model of space
and then decide how best to employ the spread rate equations along
each possible burn trajectory.

In GridFire, SIG adopted a raster grid view of space so as to reduce the
potentially exponential complexity of modeling a fractal shape (i.e.,
fire front) at high resolutions using vector approximation. This also
provided the practical benefit of being able to work directly with
widely used raster datasets, such as LANDFIRE, without a geometric
lookup step or /a priori/ translation to vector space.

In simulation tests versus FARSITE on several historical California
fires, Marco Morais wrote that he saw similarly accurate results from
both his HFire model and from FARSITE but experienced several orders
of magnitude improvement in runtime
efficiency.\citep{Peterson2011,Peterson2009,Morais2001} His
explanation for this phenomenon was in the same vein as that described
above, namely, that it was FARSITE's choice of vector space that
slowed it down versus the faster raster-based HFire system.

Taking a cue from HFire's success in this regard, GridFire has adopted
HFire's two-dimensional spread algorithm, called the
/method of adaptive timesteps and fractional distances/.
\citep{Peterson2011,Peterson2009,Morais2001} The following
pseudo-code lays out the steps taken in this procedure:

1. Inputs

   1. Read in the values shown in Table [[tab:fire-model-inputs]].

   #+NAME: tab:fire-model-inputs
   #+CAPTION: Inputs to SIG's raster-based fire behavior model
   #+ATTR_LATEX: :align |l|l|l| :font \small
   |---------------------------+-------------------------------------+------------------------------------|
   | Value                     | Units                               | Type                               |
   |---------------------------+-------------------------------------+------------------------------------|
   | max-runtime               | minutes                             | double                             |
   | cell-size                 | feet                                | double                             |
   | elevation-matrix          | feet                                | core.matrix 2D double array        |
   | slope-matrix              | vertical feet/horizontal feet       | core.matrix 2D double array        |
   | aspect-matrix             | degrees clockwise from north        | core.matrix 2D double array        |
   | fuel-model-matrix         | fuel model numbers 1-256            | core.matrix 2D double array        |
   | canopy-height-matrix      | feet                                | core.matrix 2D double array        |
   | canopy-base-height-matrix | feet                                | core.matrix 2D double array        |
   | crown-bulk-density-matrix | lb/ft^{3}                           | core.matrix 2D double array        |
   | canopy-cover-matrix       | 0-100                               | core.matrix 2D double array        |
   | wind-speed-20ft           | miles/hour                          | double                             |
   | wind-from-direction       | degrees clockwise from North        | double                             |
   | fuel-moisture             | %                                   | map of doubles per fuel size class |
   | foliar-moisture           | %                                   | double                             |
   | ellipse-adjustment-factor | $< 1.0 =$ circle, $> 1.0 =$ ellipse | double                             |
   | initial-ignition-site     | point represented as [row col]      | vector                             |
   |---------------------------+-------------------------------------+------------------------------------|

2. Initialization

   1. Verify that *initial-ignition-site* and at least one of its
      neighboring cells has a burnable fuel model (not 91-99).
      Otherwise, terminate the simulation, indicating that no fire
      spread is possible.

   2. Create three new matrices, called *fire-spread-matrix*,
      *flame-length-matrix*, and *fire-line-intensity-matrix*. All
      three are initialized to zero except for a value of 1 at the
      *initial-ignition-site*.

   3. Set *global-clock* to 0. This will track the amount of time that
      has passed since the initial ignition in minutes.

   4. Create a new hash-map, called *ignited-cells*, which maps the
      *initial-ignition-site* to a set of trajectories into each of
      its burnable neighbors. See ``Computing Burn Trajectories''
      below for the steps used in this procedure.

3. Computing Burn Trajectories

   1. Look up the fuel model, slope, aspect, canopy height, canopy
      base height, crown bulk density, and canopy cover associated
      with the ignited cell in the input matrices.

   2. Calculate the dead herbaceous size class parameters, live
      moisture of extinction, and size class weighting factors for
      this fuel model.

   3. Use the Rothermel equations to calculate the minimum surface
      rate of spread (i.e., wind = slope = 0) leaving this cell.

   4. Compute Albini and Baughman's wind adjustment factor for this
      cell using the fuel bed depth, canopy height, and canopy cover.
      Multiply this value by the 20-ft wind speed to derive the local
      midflame wind speed.

   5. Calculate the maximum surface rate of spread (and bearing)
      originating from this cell using the Rothermel equations and
      taking into account the effects of downhill and cross-slope
      winds as described in Rothermel 1983.

   6. Use the Cruz formulas to calculate the maximum crown fire spread
      rate from the 20-ft wind speed, crown bulk density, and dead
      1-hr fuel moisture.

   7. Determine the surface and crown elliptical eccentricities by
      calculating their length-to-width ratios using the equations
      from Rothermel 1991.

   8. For each burnable neighboring cell:

      1. Use the eccentricity values to determine the possible surface
         and crown rates of spread into it from the ignited cell.

      2. Compute Byram's surface fire line intensity and Rothermel's
         crown intensity from these spread rates.

      3. Apply Van Wagner's crown initiation model to determine if the
         fire will be a passive or active crown fire or remain a
         surface fire.

      4. In the surface fire case, the spread rate into this neighbor
         will simply be the surface spread rate calculated above. The
         fire line intensity is the surface fire line intensity, and
         the flame length is calculated from this intensity value
         using Byram's relation.

      5. In the case of a crown fire, the spread rate into this
         neighbor will be the maximum of the surface and crown spread
         rates. The fire line intensity is the sum of the surface and
         crown intensities, and the flame length is once again
         computed from Byram's relation.

      6. Store this neighboring cell, the bearing to it from the
         ignited cell, and the spread rate, fire line intensity, and
         flame length values computed above in a burn trajectory
         record. Also include the terrain (e.g., 3d) distance between
         this cell and the ignited cell. Finally, set its
         *fractional-distance* value to be 0, or in the event that
         this bearing matches an overflow bearing from a previous
         iteration, set it to the *overflow-heat* value.

   9. Return a collection of burn trajectory records, one per burnable
      neighboring cell.

4. Main Loop

   1. If *global-clock* has not yet reached *max-runtime* and
      *ignited-cells* is not empty, proceed to 4.(b). Otherwise, jump
      to 5.(a).

   2. The timestep for this iteration of the model is calculated by
      dividing *cell-size* by the maximum spread rate into any cell
      from those cells in the *ignited-cells* map. As spread rates
      increase, the timesteps grow shorter and the model takes more
      iterations to complete. Similarly, the model has longer
      timesteps and takes less iterations as spread rates decrease.
      This is called the /method of adaptive timesteps/.

   3. If the timestep calculated in 4.(b) would cause the
      *global-clock* to exceed the max-runtime, then the timestep is
      set to the difference between *max-runtime* and *global-clock*.

   4. For each burn trajectory in *ignited-cells*:

      1. Multiply the spread rate (ft/min) by the timestep (min) to
         get the distance traveled by the fire (ft) along this path
         during this iteration.

      2. Divide this distance traveled by the terrain distance between
         these two cells to get the new spread fraction $\in [0,1]$
         and increment the *fractional-distance* associated with the
         trajectory by this value.

      3. If the new *fractional-distance* is greater than or equal to
         1, append this updated burn trajectory record to a list
         called *ignition-events*.

   5. If more than one trajectory in *ignition-events* shares the same
      target cell, retain only the trajectory with the largest
      *fractional-distance* value.

   6. For each trajectory in *ignition-events*:

      1. Set the target cell's value to 1 in *fire-spread-matrix*,
         *flame-length* in *flame-length-matrix*, and
         *fire-line-intensity* in *fire-line-intensity-matrix*.

      2. If the target cell has any burnable neighbors, append an
         entry to *ignited-cells*, mapping this cell to each of the
         burn trajectories emanating from it, which are calculated by
         following the steps in section ``Computing Burn
         Trajectories'' above. If its *fractional-distance* value is
         greater than 1, add the overflow amount above 1 to the
         outgoing trajectory with the same bearing along which this
         cell was ignited. That is, if this cell was ignited by a
         neighbor to the southeast, then pass any overflow heat onto
         the trajectory leading to the northwest.

   7. Remove any trajectories from *ignited-cells* that have as their
      targets any of the cells in *ignition-events*.

   8. Remove any cells from *ignited-cells* that no longer have any
      burnable neighbors.

   9. Increment the *global-clock* by this iteration's *timestep*.

   10. Repeat from 4.(a).

5. Outputs

   1. Return an associative map with the fields shown in Table
      [[tab:fire-model-outputs]].

   #+NAME: tab:fire-model-outputs
   #+CAPTION: Outputs from SIG's raster-based fire behavior model
   #+ATTR_LATEX: :align |l|l|l| :font \small
   |----------------------------+-----------------------------------------+-----------------------------|
   | Value                      | Units                                   | Type                        |
   |----------------------------+-----------------------------------------+-----------------------------|
   | global-clock               | minutes                                 | double                      |
   | initial-ignition-site      | point represented as [row col]          | vector                      |
   | ignited-cells              | list of points represented as [row col] | list of vectors             |
   | fire-spread-matrix         | [0,1]                                   | core.matrix 2D double array |
   | flame-length-matrix        | feet                                    | core.matrix 2D double array |
   | fire-line-intensity-matrix | Btu/ft/s                                | core.matrix 2D double array |
   |----------------------------+-----------------------------------------+-----------------------------|

#+name: fire-spread-algorithm
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fire_spread.clj :padline no :no-expand :comments link
(ns gridfire.fire-spread
  (:require [clojure.core.matrix           :as m]
            [clojure.core.matrix.operators :as mop]
            [gridfire.common               :refer [extract-constants
                                                   fuel-moisture
                                                   in-bounds?
                                                   burnable-fuel-model?
                                                   burnable?]]
            [gridfire.crown-fire           :refer [crown-fire-eccentricity
                                                   crown-fire-line-intensity
                                                   cruz-crown-fire-spread
                                                   van-wagner-crown-fire-initiation?]]
            [gridfire.fuel-models          :refer [build-fuel-model moisturize]]
            [gridfire.surface-fire         :refer [anderson-flame-depth
                                                   byram-fire-line-intensity
                                                   byram-flame-length
                                                   rothermel-surface-fire-spread-any
                                                   rothermel-surface-fire-spread-max
                                                   rothermel-surface-fire-spread-no-wind-no-slope
                                                   wind-adjustment-factor]]
            [gridfire.perturbation         :as perturbation]
            [gridfire.spotting             :as spotting]))

(m/set-current-implementation :vectorz)

;; for surface fire, tau = 10 mins, t0 = 0, and t = global-clock
;; for crown fire, tau = 20 mins, t0 = time of first torch, t = global-clock
;; (defn lautenberger-spread-acceleration
;;   [equilibrium-spread-rate t0 t tau]
;;   (* equilibrium-spread-rate (- 1.0 (Math/exp (/ (- t0 t 0.2) tau)))))
;;
;; Note: Because of our use of adaptive timesteps, if the spread rate on
;;       the first timestep is not at least 83 ft/min, then the timestep will
;;       be calculated as greater than 60 minutes, which will terminate the
;;       one hour fire simulation instantly.

(defn random-cell
  "Returns a random [i j] pair with i < num-rows and j < num-cols."
  [num-rows num-cols]
  [(rand-int num-rows)
   (rand-int num-cols)])

(defn get-neighbors
  "Returns the eight points adjacent to the passed-in point."
  [[i j]]
  (let [i- (- i 1)
        i+ (+ i 1)
        j- (- j 1)
        j+ (+ j 1)]
    (vector [i- j-] [i- j] [i- j+]
            [i  j-]        [i  j+]
            [i+ j-] [i+ j] [i+ j+])))

(defn distance-3d
  "Returns the terrain distance between two points in feet."
  [elevation-matrix cell-size [i1 j1] [i2 j2]]
  (let [di (* cell-size (- i1 i2))
        dj (* cell-size (- j1 j2))
        dz (- (m/mget elevation-matrix i1 j1)
              (m/mget elevation-matrix i2 j2))]
    (Math/sqrt (+ (* di di) (* dj dj) (* dz dz)))))

(def offset-to-degrees
  "Returns clockwise degrees from north."
  {[-1  0]   0.0   ; N
   [-1  1]  45.0   ; NE
   [ 0  1]  90.0   ; E
   [ 1  1] 135.0   ; SE
   [ 1  0] 180.0   ; S
   [ 1 -1] 225.0   ; SW
   [ 0 -1] 270.0   ; W
   [-1 -1] 315.0}) ; NW

(def rothermel-fast-wrapper
  (memoize
   (fn [fuel-model-number fuel-moisture]
     (let [fuel-model      (-> (build-fuel-model (int fuel-model-number))
                               (moisturize fuel-moisture))
           spread-info-min (rothermel-surface-fire-spread-no-wind-no-slope fuel-model)]
       [fuel-model spread-info-min]))))

(defn compute-burn-trajectory
  [neighbor here spread-info-min spread-info-max fuel-model crown-bulk-density
   canopy-cover canopy-height canopy-base-height foliar-moisture crown-spread-max
   crown-eccentricity landfire-rasters cell-size overflow-trajectory overflow-heat]
  (let [trajectory          (mop/- neighbor here)
        spread-direction    (offset-to-degrees trajectory)
        surface-spread-rate (rothermel-surface-fire-spread-any spread-info-max
                                                               spread-direction)
        residence-time      (:residence-time spread-info-min)
        reaction-intensity  (:reaction-intensity spread-info-min)
        surface-intensity   (->> (anderson-flame-depth surface-spread-rate residence-time)
                                 (byram-fire-line-intensity reaction-intensity))
        crown-fire?         (van-wagner-crown-fire-initiation? canopy-cover
                                                               canopy-base-height
                                                               foliar-moisture
                                                               surface-intensity)
        crown-spread-rate   (if crown-fire?
                              (rothermel-surface-fire-spread-any
                               (assoc spread-info-max
                                      :max-spread-rate crown-spread-max
                                      :eccentricity crown-eccentricity)
                               spread-direction))
        crown-intensity     (if crown-fire?
                              (crown-fire-line-intensity
                               crown-spread-rate
                               crown-bulk-density
                               canopy-height
                               canopy-base-height
                               (-> fuel-model :h :dead :1hr)))
        spread-rate         (if crown-fire?
                              (max surface-spread-rate crown-spread-rate)
                              surface-spread-rate)
        fire-line-intensity (if crown-fire?
                              (+ surface-intensity crown-intensity)
                              surface-intensity)
        flame-length        (byram-flame-length fire-line-intensity)]
    {:cell                neighbor
     :trajectory          trajectory
     :terrain-distance    (distance-3d (:elevation landfire-rasters) cell-size here neighbor)
     :spread-rate         spread-rate
     :fire-line-intensity fire-line-intensity
     :flame-length        flame-length
     :fractional-distance (volatile! (if (= trajectory overflow-trajectory)
                                       overflow-heat
                                       0.0))
     :crown-fire?         crown-fire?}))

(defn compute-neighborhood-fire-spread-rates!
   "Returns a vector of entries of the form:
  {:cell [i j],
   :trajectory [di dj],
   :terrain-distance ft,
   :spread-rate ft/min,
   :fire-line-intensity Btu/ft/s,
   :flame-length ft,
   :fractional-distance [0-1]}, one for each cell adjacent to here."
  [{:keys [landfire-rasters foliar-moisture ellipse-adjustment-factor cell-size num-rows num-cols] :as constants}
   fire-spread-matrix
   [i j :as here]
   overflow-trajectory
   overflow-heat
   global-clock]
  (let [{:keys
         [aspect
          canopy-base-height
          canopy-cover
          canopy-height
          crown-bulk-density
          fuel-model
          relative-humidity
          slope
          temperature
          wind-from-direction
          wind-speed-20ft]}          (extract-constants constants global-clock here)
        fuel-moisture                (fuel-moisture relative-humidity temperature)
        [fuel-model spread-info-min] (rothermel-fast-wrapper fuel-model fuel-moisture)
        midflame-wind-speed          (* wind-speed-20ft 88.0
                                        (wind-adjustment-factor (:delta fuel-model) canopy-height canopy-cover)) ; mi/hr -> ft/min
        spread-info-max              (rothermel-surface-fire-spread-max spread-info-min
                                                                        midflame-wind-speed
                                                                        wind-from-direction
                                                                        slope
                                                                        aspect
                                                                        ellipse-adjustment-factor)
        crown-spread-max             (cruz-crown-fire-spread wind-speed-20ft crown-bulk-density
                                                             (-> fuel-moisture :dead :1hr))
        crown-eccentricity           (crown-fire-eccentricity wind-speed-20ft
                                                              ellipse-adjustment-factor)]
    (into []
          (comp
           (filter #(and (in-bounds? num-rows num-cols %)
                         (burnable? fire-spread-matrix (:fuel-model landfire-rasters) %)))
           (map #(compute-burn-trajectory % here spread-info-min spread-info-max fuel-model
                                          crown-bulk-density canopy-cover canopy-height
                                          canopy-base-height foliar-moisture crown-spread-max
                                          crown-eccentricity landfire-rasters cell-size
                                          overflow-trajectory overflow-heat)))
          (get-neighbors here))))

(defn burnable-neighbors?
  [fire-spread-matrix fuel-model-matrix num-rows num-cols cell]
  (some #(and (in-bounds? num-rows num-cols %)
              (burnable? fire-spread-matrix fuel-model-matrix %))
        (get-neighbors cell)))

(defn select-random-ignition-site
  [fuel-model-matrix]
  (let [num-rows           (m/row-count    fuel-model-matrix)
        num-cols           (m/column-count fuel-model-matrix)
        fire-spread-matrix (m/zero-matrix num-rows num-cols)]
    (loop [[i j :as ignition-site] (random-cell num-rows num-cols)]
      (if (and (burnable-fuel-model? (m/mget fuel-model-matrix i j))
               (burnable-neighbors? fire-spread-matrix fuel-model-matrix
                                    num-rows num-cols ignition-site))
        ignition-site
        (recur (random-cell num-rows num-cols))))))

(defn identify-ignition-events
  [ignited-cells timestep]
  (->> (for [[_ destinations] ignited-cells
             {:keys [cell trajectory terrain-distance spread-rate flame-length
                     fire-line-intensity fractional-distance crown-fire?]} destinations]
         (let [new-spread-fraction (/ (* spread-rate timestep) terrain-distance)
               new-total           (vreset! fractional-distance
                                            (+ @fractional-distance new-spread-fraction))]
           (if (>= new-total 1.0)
             {:cell cell :trajectory trajectory :fractional-distance @fractional-distance
              :flame-length flame-length :fire-line-intensity fire-line-intensity
              :crown-fire? crown-fire?})))
       (remove nil?)
       (group-by :cell)
       (map (fn [[_ trajectories]] (apply max-key :fractional-distance trajectories)))
       (into [])))

(defn update-ignited-cells
  [{:keys [landfire-rasters num-rows num-cols] :as constants}
   ignited-cells
   ignition-events
   fire-spread-matrix
   global-clock]
  (let [newly-ignited-cells (into #{} (map :cell) ignition-events)
        fuel-model-matrix   (:fuel-model landfire-rasters)]
    (into {}
          (concat
           (for [[cell spread-info] ignited-cells
                 :when (burnable-neighbors? fire-spread-matrix fuel-model-matrix
                                            num-rows num-cols cell)]
             [cell (remove #(contains? newly-ignited-cells (:cell %)) spread-info)])
           (for [{:keys [cell trajectory fractional-distance]} ignition-events
                 :when (burnable-neighbors? fire-spread-matrix fuel-model-matrix
                                            num-rows num-cols cell)]
             [cell (compute-neighborhood-fire-spread-rates!
                    constants
                    fire-spread-matrix
                    cell
                    trajectory
                    (- fractional-distance 1.0)
                    global-clock)])))))

(defn generate-ignited-cells [constants fire-spread-matrix cells]
  (when (seq cells)
    (into {}
          (for [cell cells]
            [cell (compute-neighborhood-fire-spread-rates!
                   constants
                   fire-spread-matrix
                   cell
                   nil
                   0.0
                   0.0)]))))

(defn identify-spot-ignition-events
  [global-clock spot-ignitions]
  (let [to-ignite-now (group-by (fn [[cell [time ign-prob]]]
                                  (>= global-clock time))
                                spot-ignitions)
        ignite-later  (into {} (get to-ignite-now false))
        ignite-now    (into {} (get to-ignite-now true))]
    [ignite-later ignite-now]))

(defn spot-ignited-cells
  [constants
   global-clock
   {:keys [fire-spread-matrix
           burn-time-matrix]}
   spot-ignite-now]
  (let [ignited-cells (generate-ignited-cells constants
                                              fire-spread-matrix
                                              (keys spot-ignite-now))]
    (doseq [cell spot-ignite-now
            :let [[i j] (key cell)]]
      (m/mset! fire-spread-matrix i j 1.0)
      (m/mset! burn-time-matrix i j global-clock))
    ignited-cells))

(defn new-spot-ignitions
  [{:keys [spotting] :as config} constants matrices ignition-events]
  (when spotting
    (reduce (fn [acc ignition-event]
              (merge-with (partial min-key first)
                          acc
                          (->> (spot/spread-firebrands
                                constants
                                config
                                matrices
                                ignition-event)
                               (into {}))))
            {}
            ignition-events)))


(defn run-loop
  [{:keys [max-runtime cell-size initial-ignition-site multiplier-lookup] :as constants}
   {:keys [spotting] :as config}
   {:keys [fire-spread-matrix
           flame-length-matrix
           fire-line-intensity-matrix
           firebrand-count-matrix
           burn-time-matrix] :as matrices}
   ignited-cells]
  (loop [global-clock      0.0
         ignited-cells     ignited-cells
         spot-ignitions {}]
    (if (and (< global-clock max-runtime)
             (seq ignited-cells))
      (let [dt                (->> ignited-cells
                                   (vals)
                                   (apply concat)
                                   (map :spread-rate)
                                   (reduce max 0.0)
                                   (/ cell-size))
            timestep          (if (> (+ global-clock dt) max-runtime)
                                (- max-runtime global-clock)
                                dt)
            next-global-clock (+ global-clock timestep)
            ignition-events   (identify-ignition-events ignited-cells timestep)
            constants         (perturbation/update-global-vals constants global-clock next-global-clock)]
        ;; [{:cell :trajectory :fractional-distance
        ;;   :flame-length :fire-line-intensity} ...]
        (doseq [{:keys [cell flame-length fire-line-intensity] :as ignition-event} ignition-events]
          (let [[i j] cell]
            (m/mset! fire-spread-matrix         i j 1.0)
            (m/mset! flame-length-matrix        i j flame-length)
            (m/mset! fire-line-intensity-matrix i j fire-line-intensity)
            (m/mset! burn-time-matrix           i j global-clock)))
        (let [new-spot-ignitions (new-spot-ignitions config
                                                     (assoc constants :global-clock global-clock)
                                                     matrices
                                                     ignition-events)
              [spot-ignite-later
               spot-ignite-now]  (identify-spot-ignition-events global-clock
                                                                (merge-with (partial min-key first)
                                                                            spot-ignitions
                                                                            new-spot-ignitions))
              spot-ignited-cells (spot-ignited-cells constants
                                                     global-clock
                                                     matrices
                                                     spot-ignite-now)]
          (recur next-global-clock
                 (update-ignited-cells constants
                                       (merge spot-ignited-cells ignited-cells)
                                       ignition-events
                                       fire-spread-matrix
                                       global-clock)
                 spot-ignite-later)))
      {:exit-condition             (if (seq ignited-cells) :max-runtime-reached :no-burnable-fuels)
       :fire-spread-matrix         fire-spread-matrix
       :flame-length-matrix        flame-length-matrix
       :fire-line-intensity-matrix fire-line-intensity-matrix
       :burn-time-matrix           burn-time-matrix})))

(defn- initialize-matrix
  [num-rows num-cols indices]
  (let [matrix (m/zero-matrix num-rows num-cols)]
    (doseq [[i j] indices
            :when (in-bounds? num-rows num-cols [i j])]
      (m/mset! matrix i j -1.0))
    matrix))

(defn- get-non-zero-indices [m]
  (for [[r cols] (map-indexed vector (m/non-zero-indices m))
        c        cols]
    [r c]))

(defmulti run-fire-spread
  "Runs the raster-based fire spread model with a map of these arguments:
  - max-runtime: double (minutes)
  - cell-size: double (feet)
  - landfire-rasters: map containing these entries;
    - elevation: core.matrix 2D double array (feet)
    - slope: core.matrix 2D double array (vertical feet/horizontal feet)
    - aspect: core.matrix 2D double array (degrees clockwise from north)
    - fuel-model: core.matrix 2D double array (fuel model numbers 1-256)
    - canopy-height: core.matrix 2D double array (feet)
    - canopy-base-height: core.matrix 2D double array (feet)
    - crown-bulk-density: core.matrix 2D double array (lb/ft^3)
    - canopy-cover: core.matrix 2D double array (0-100)
  - wind-speed-20ft: double (miles/hour)
  - wind-from-direction: double (degrees clockwise from north)
  - fuel-moisture: doubles (%){:dead {:1hr :10hr :100hr} :live {:herbaceous :woody}}
  - foliar-moisture: double (%)
  - ellipse-adjustment-factor: (< 1.0 = more circular, > 1.0 = more elliptical)
  - initial-ignition-site: One of the following:
     - point represented as [row col]
     - map containing a :matrix field of type core.matrix 2D double array (0-2)
     - nil (this causes GridFire to select a random ignition-point)
  - num-rows: integer
  - num-cols: integer"
  (fn [{:keys [initial-ignition-site]} _]
    (condp = (type initial-ignition-site)
      clojure.lang.PersistentHashMap :ignition-perimeter
      clojure.lang.PersistentVector  :ignition-point
      :random-ignition-point)))

(defmethod run-fire-spread :random-ignition-point
  [{:keys [landfire-rasters] :as constants} config]
  (run-fire-spread (assoc constants
                          :initial-ignition-site
                          (select-random-ignition-site (:fuel-model landfire-rasters)))
                   config))

(defmethod run-fire-spread :ignition-point
  [{:keys [landfire-rasters num-rows num-cols initial-ignition-site] :as constants}
   {:keys [spotting] :as config}]
  (let [[i j]                      initial-ignition-site
        fuel-model-matrix          (:fuel-model landfire-rasters)
        fire-spread-matrix         (m/zero-matrix num-rows num-cols)
        flame-length-matrix        (m/zero-matrix num-rows num-cols)
        fire-line-intensity-matrix (m/zero-matrix num-rows num-cols)
        burn-time-matrix           (m/zero-matrix num-rows num-cols)
        firebrand-count-matrix     (when spotting (m/zero-matrix num-rows num-cols))]
    (when (and (in-bounds? num-rows num-cols initial-ignition-site)
               (burnable-fuel-model? (m/mget fuel-model-matrix i j))
               (burnable-neighbors? fire-spread-matrix fuel-model-matrix
                                    num-rows num-cols initial-ignition-site))
      ;; initialize the ignition site
      (m/mset! fire-spread-matrix i j 1.0)
      (m/mset! flame-length-matrix i j 1.0)
      (m/mset! fire-line-intensity-matrix i j 1.0)
      (let [ignited-cells {initial-ignition-site
                           (compute-neighborhood-fire-spread-rates!
                            constants
                            fire-spread-matrix
                            initial-ignition-site
                            nil
                            0.0
                            0.0)}]
        (run-loop constants
                  config
                  {:fire-spread-matrix         fire-spread-matrix
                   :flame-length-matrix        flame-length-matrix
                   :fire-line-intensity-matrix fire-line-intensity-matrix
                   :firebrand-count-matrix     firebrand-count-matrix
                   :burn-time-matrix           burn-time-matrix}
                  ignited-cells)))))

(defmethod run-fire-spread :ignition-perimeter
  [{:keys [num-rows num-cols initial-ignition-site landfire-rasters] :as constants}
   {:keys [spotting] :as config}]
  (let [fire-spread-matrix         (first (m/mutable (:matrix initial-ignition-site)))
        non-zero-indices           (get-non-zero-indices fire-spread-matrix)
        flame-length-matrix        (initialize-matrix num-rows num-cols non-zero-indices)
        fire-line-intensity-matrix (initialize-matrix num-rows num-cols non-zero-indices)
        perimeter-indices          (filter #(burnable-neighbors? fire-spread-matrix
                                                                 (:fuel-model landfire-rasters)
                                                                 num-rows
                                                                 num-cols
                                                                 %)
                                           non-zero-indices)
        burn-time-matrix           (initialize-matrix num-rows num-cols non-zero-indices)
        firebrand-count-matrix     (when spotting (m/zero-matrix num-rows num-cols))
        ignited-cells              (generate-ignited-cells constants fire-spread-matrix non-zero-indices)]
    (run-loop constants
              config
              {:fire-spread-matrix         fire-spread-matrix
               :flame-length-matrix        flame-length-matrix
               :fire-line-intensity-matrix fire-line-intensity-matrix
               :firebrand-count-matrix     firebrand-count-matrix
               :burn-time-matrix           burn-time-matrix}
              ignited-cells)))
#+end_src

This concludes our description of GridFire's raster-based fire spread
algorithm.

* Spotting Model
** Spotting Model Definitions
** Spotting Model Forumulas
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/spotting.clj :padline no :no-expand :comments link
(ns gridfire.spotting
  (:require [clojure.core.matrix :as m]
            [gridfire.common :refer [extract-constants
                                     distance-3d
                                     fuel-moisture
                                     in-bounds?
                                     burnable?]]
            [gridfire.crown-fire :refer [ft->m]]
            [gridfire.utils.random :refer [random-float]]
            [gridfire.conversion :as convert]
            [kixi.stats.distribution :as distribution]))

;;-----------------------------------------------------------------------------
;; Formulas
;;-----------------------------------------------------------------------------

(defn froude-number
  "Returns froude number given:
  wind-speed-20ft: (ms^-1)
  fire-line-intensity: (kWm^-1)
  temperature: (Kelvin)
  ambient-gas-density: (kgm^-3)
  specific-heat-gas: (KJkg^-1 K^-1)"
  [wind-speed-20ft fire-line-intensity temperature ambient-gas-density specific-heat-gas]
  (let [g   9.81 ;(ms^-1) gravity
        L_c (-> (/ fire-line-intensity ;characteristic length of plume
                   (* ambient-gas-density
                      specific-heat-gas
                      temperature
                      (Math/sqrt g)))
                (Math/pow (/ 2 3)))]
    (/ wind-speed-20ft
       (Math/sqrt (* g L_c)))))

(defn buoyancy-driven? [froude]
  (<= froude 1))

(defn deviation-fb
  "Returns standard deviation as described in Perryman 2013 EQ5 and EQ6 given:
  froude number: (Int)
  fire-line-intensity: (kWm^-1)
  wind-speed-20ft: (ms^-1)"
  [froude fire-line-intensity wind-speed-20ft]
  (if (buoyancy-driven? froude)
    (+ (* 0.86 (Math/pow fire-line-intensity -0.21) (Math/pow wind-speed-20ft 0.44)) 0.19)
    (- (* 4.95 (Math/pow fire-line-intensity -0.01) (Math/pow wind-speed-20ft -0.02)) 3.48)))

(defn mean-fb
  "Returns mean as described in Perryman 2013 EQ5 and EQ6 given:
  froude number: (Int)
  fire-line-intensity: (kWm^-1)
  wind-speed-20ft: (ms^-1)"
  [froude fire-line-intensity wind-speed-20ft]
  (if (buoyancy-driven? froude)
    (+ (* 1.47 (Math/pow fire-line-intensity 0.54) (Math/pow wind-speed-20ft -0.55)) 1.14)
    (- (* 1.32 (Math/pow fire-line-intensity 0.26) (Math/pow wind-speed-20ft 0.11)) 0.02)))

(defn specific-heat-dry-fuel
  "Returns specific heat of dry fuel given:
  initiial-temp: (Celcius)
  ignition-temp: (Celcius)
  "
  [initial-temp ignition-temp]
  (+ 0.266 (* 0.0016 (/ (+ ignition-temp initial-temp) 2))))

(defn heat-of-preignition
  "Returns heat of preignition given:
  init-temperature: (Celcius)
  ignition-temperature: (Celcius)
  moisture content: (Percent)"
  [init-temperature ignition-temperature moisture]
  (let [T_o init-temperature
        T_i ignition-temperature
        M   moisture
        c_f (specific-heat-dry-fuel T_o T_i)

        ;; heat required to reach ignition temperature
        Q_a (* (- T_i T_o) c_f)

        ;; heat required to raise moisture to reach boiling point
        Q_b (* (- 100 T_o) M)

        ;; Heat of desorption
        Q_c (* 18.54 (- 1 (Math/exp (* -15.1 M))))

        ;; Heat required to vaporize moisture
        Q_d (* 540 M)]
    (+ Q_a Q_b Q_c Q_d)))

(defn schroeder-ign-prob
  "Returns the probability of ignition as described in Shroeder (1969) given:
  relative-humidity: (%)
  temperature: (Farenheit)"
  [relative-humidity temperature]
  (let [ignition-temperature 320 ;;FIXME should this be a constant?
        moisture             (-> (fuel-moisture relative-humidity temperature)
                                 :dead
                                 :1hr)
        Q_ig                 (heat-of-preignition (convert/F->C temperature) ignition-temperature moisture)
        X                    (/ (- 400 Q_ig) 10)]
    (/ (* 0.000048 (Math/pow X 4.3)) 50)))

(defn spot-ignition-probability
  [{:keys [cell-size landfire-layers]}
   {:keys [decay-constant] :as spot-config}
   temperature
   relative-humidity
   firebrand-count
   torched-origin
   [i j :as here]]
  (let [ignition-probability (schroeder-ign-prob relative-humidity
                                                 temperature)
        distance             (ft->m (distance-3d (:elevation landfire-layers)
                                                 cell-size
                                                 here
                                                 torched-origin))
        decay-factor         (Math/exp (* -1 decay-constant distance))]
    (- 1 (Math/pow (- 1 (* ignition-probability decay-factor)) firebrand-count))))

(defn spot-ignition?
  [rand-gen spot-ignition-probability]
  (let [random-number (random-float 0 1 rand-gen)]
    (> spot-ignition-probability random-number)))

(defn spot-ignition-time
  [global-clock flame-length-matrix [i j]]
  (let [a            5.963
        b            (- a 1.4)
        z-max        (* 0.39 0.003 (Math/pow 10 5))
        flame-length (m/mget flame-length-matrix i j)
        time-delta   (+ 1.2 (* (/ a 3.0)
                               (- (Math/pow (/ (+ b (/ z-max flame-length)) a) (/ 3.0 2.0)) 1)))]
    (+ global-clock time-delta)))

;;-----------------------------------------------------------------------------
;; Main
;;-----------------------------------------------------------------------------

(defn sample-wind-dir-deltas
  "Returns a sequence of [x y] distances (meters) that firebrands land away
  from a torched cell at i j where:
  x: parallel to the wind
  y: perpendicular to the wind (positive values are to the right of wind direction)"
  [{:keys [spotting random-seed] :as config}
   fire-line-intensity-matrix
   wind-speed-20ft
   temperature
   [i j]]
  (let [{:keys
         [num-firebrands
          ambient-gas-density
          specific-heat-gas]} spotting
        intensity             (convert/Btu-ft-s->kW-m (m/mget fire-line-intensity-matrix i j))
        froude                (froude-number intensity
                                             wind-speed-20ft
                                             temperature
                                             ambient-gas-density
                                             specific-heat-gas)
        parallel              (distribution/log-normal {:mu (mean-fb froude intensity wind-speed-20ft)
                                                        :sd (deviation-fb froude intensity wind-speed-20ft)})
        perpendicular         (distribution/normal {:mu 0
                                                    :sd 0.92})]
    (map (comp
          (partial mapv convert/m->ft)
          vector)
         (distribution/sample num-firebrands parallel {:seed random-seed})
         (distribution/sample num-firebrands perpendicular {:seed random-seed}))))

(defn hypotenuse [x y]
  (Math/sqrt (+ (Math/pow x 2) (Math/pow y 2))))

(defn deltas-wind-dir->coord
  "Converts deltas from the torched tree in the wind direction to deltas
  in the coordinate plane"
  [deltas wind-direction]
  (map (fn [[d-paral d-perp]]
         (let [H  (hypotenuse d-paral d-perp)
               t1 wind-direction
               t2 (convert/rad->deg (Math/atan (/ d-perp d-paral)))
               t3 (+ t1 t2)]
           [(* -1 H (Math/cos (convert/deg->rad t3)))
            (* H (Math/sin (convert/deg->rad t3)))]))
       deltas))

(defn firebrands
  "Returns a sequence of cells that firebrands land in"
  [deltas wind-towards-dir cell cell-size]
  (let [step         (/ cell-size 2)
        cell-center  (mapv #(+ step (* % step)) cell)
        coord-deltas (deltas-wind-dir->coord deltas wind-towards-dir)]
    (map (comp
          (partial map int)
          (partial map #(quot % step))
          (partial map + cell-center))
         coord-deltas)))

(defn update-firebrand-counts!
  [{:keys [num-rows num-cols landfire-layers]}
   firebrand-count-matrix
   fire-spread-matrix
   firebrands]
  (doseq [[x y :as here] firebrands
          :when          (and (in-bounds? num-rows num-cols [x y])
                              (burnable? fire-spread-matrix
                                         (:fuel-model landfire-layers)
                                         here))
          :let           [new-count (inc (m/mget firebrand-count-matrix x y))]]
    (m/mset! firebrand-count-matrix x y new-count)))

(defn spread-firebrands
  "Returns a sequence of key value pairs where
  key: [x y] locations of the cell
  val: [t p] where t = time of ignition and p = ignition-probability"
  [{:keys
    [num-rows num-cols cell-size landfire-layers wind-speed-20ft
     wind-from-direction temperature relative-humidity
     global-clock multiplier-lookup perturbations] :as constants}
   {:keys [spotting rand-gen random-seed] :as config}
   {:keys [firebrand-count-matrix
           fire-spread-matrix
           fire-line-intensity-matrix
           flame-length-matrix]}
   {:keys [cell fire-line-intensity crown-fire?] :as ignition-event}]
  (when crown-fire?
    (let [{:keys
           [wind-speed-20ft
            temperature
            wind-from-direction
            relative-humidity]} (extract-constants constants global-clock cell)
          deltas                (sample-wind-dir-deltas config
                                                        fire-line-intensity-matrix
                                                        (convert/mph->mps wind-speed-20ft)
                                                        (convert/F->K temperature)
                                                        cell)
          wind-to-direction     (mod (+ 180 wind-from-direction) 360)
          firebrands            (firebrands deltas wind-to-direction cell cell-size)]
      (update-firebrand-counts! constants firebrand-count-matrix fire-spread-matrix firebrands)
      (->> (for [[x y] firebrands
                 :when (and (in-bounds? num-rows num-cols [x y])
                            (burnable? fire-spread-matrix (:fuel-model landfire-layers) [x y]))
                 :let  [firebrand-count (m/mget firebrand-count-matrix x y)
                        spot-ignition-p (spot-ignition-probability constants
                                                                   spotting
                                                                   temperature
                                                                   relative-humidity
                                                                   firebrand-count
                                                                   cell
                                                                   [x y])]]
             (when (spot-ignition? rand-gen spot-ignition-p)
               [[x y] [(spot-ignition-time global-clock flame-length-matrix cell) spot-ignition-p]]))
           (remove nil?)))))
#+end_src
* User Interface

The GridFire model described in the previous section may be called
directly from the REPL through the *run-fire-spread* function.
However, this would require that the user had already prepared all of
their map layers as 2D Clojure core.matrix values. In order to enable
GridFire to easily access a wide range of raster formatted GIS layers
directly, we have the following options:

1. A simple Clojure interface to a Postgresql database, containing
   the PostGIS spatial extensions. This interface is described in
   Section [[PostGIS Bridge]].

2. Magellan, a Clojure library for interacting with geospatial
   datasets. This interface is described in Section [[Magellan]].

Section [[Command Line Interface]] describes GridFire's command line
interface along with its input configuration file format, which
allows users to select between the PostGIS and Magellan data import
options easily.

Using one of these options along with a simple client interface in
clojure Section [[Command Line Interface]] which describes GridFire's
command line interface along with its input configuration file format.

** PostGIS Bridge

Extracting raster layers from a PostGIS database is performed by a
single function, called *postgis-raster-to-matrix*, which constructs a
SQL query for the layer, sends it to the database in a transaction,
and returns the result as a core.matrix 2D double array with nodata
values represented as -1.0. The georeferencing information associated
with this tile is also included in the returned results. This function
may be called directly from the REPL or indirectly through GridFire's
command line interface.

#+name: postgis-bridge
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/postgis_bridge.clj :padline no :no-expand :comments link
(ns gridfire.postgis-bridge
  (:require [clojure.core.matrix :as m]
            [clojure.java.jdbc   :as jdbc])
  (:import org.postgresql.jdbc.PgArray))

(m/set-current-implementation :vectorz)

(defn extract-matrix [result]
  (->> result
       :matrix
       (#(.getArray ^PgArray %))
       (m/emap #(or % -1.0))
       m/matrix))

(defn construct-data-query
  ([numbands table-name]
   (format (str "SELECT ST_DumpValues(rast,band) AS matrix "
                "FROM generate_series(1,%s) AS band "
                "CROSS JOIN %s")
           numbands
           table-name))

  ([numbands table-name threshold-query]
   (format (str "SELECT ST_DumpValues(%s,band) AS matrix "
                "FROM generate_series(1,%s) AS band "
                "CROSS JOIN %s")
           threshold-query
           numbands
           table-name)))

(defn postgis-raster-to-matrix
  "Send a SQL query to the PostGIS database given by db-spec for a
  raster tile from table table-name. Optionally resample the raster to
  match resolution and set any values below threshold to 0. Return the
  post-processed raster values as a Clojure matrix using the
  core.matrix API along with all of the georeferencing information
  associated with this tile in a hash-map with the following form:
  {:srid 900916,
   :upperleftx -321043.875,
   :upperlefty -1917341.5,
   :width 486,
   :height 534,
   :scalex 2000.0,
   :scaley -2000.0,
   :skewx 0.0,
   :skewy 0.0,
   :numbands 10,
   :matrix #vectorz/matrix Large matrix with shape: [10,534,486]}"
  ([db-spec table-name]
   (jdbc/with-db-transaction [conn db-spec]
     (let [meta-query (str "SELECT (ST_Metadata(rast)).* FROM " table-name)
           metadata   (first (jdbc/query conn [meta-query]))
           data-query (construct-data-query (:numbands metadata) table-name)
           matrix     (when-let [results (seq (jdbc/query conn [data-query]))]
                        (m/matrix (mapv extract-matrix results)))]
       (assoc metadata :matrix matrix))))

  ([db-spec table-name resolution threshold]
   (let [rescale-query   (if resolution
                           (format "ST_Rescale(rast,%s,-%s,'NearestNeighbor')"
                                   resolution resolution)
                           "rast")
         threshold-query (if threshold
                           (format (str "ST_MapAlgebra(%s, band, NULL,"
                                        "'CASE WHEN [rast.val] < %s"
                                        " THEN 0.0 ELSE [rast.val] END')")
                                   rescale-query threshold)
                           rescale-query)
         meta-query      (format "SELECT (ST_Metadata(%s)).* FROM %s"
                                 rescale-query table-name)]
     (jdbc/with-db-transaction [conn db-spec]
       (let [metadata   (first (jdbc/query conn [meta-query]))
             data-query (construct-data-query (:numbands metadata) table-name threshold-query)
             matrix     (when-let [results (seq (jdbc/query conn [data-query]))]
                          (m/matrix (mapv extract-matrix results)))]
         (assoc metadata :matrix matrix))))))
#+end_src

** Magellan

Reading raster layers from disk is performed by a single function,
called *geotiff-raster-to-matrix*. Given the location of a GeoTIFF
file, this function will read the raster into memory and return the
same map of information as the *postgis-raster-to-matrix* function,
described in the previous section.

#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/magellan_bridge.clj :padline no :no-expand :comments link
(ns gridfire.magellan-bridge
  (:require [clojure.core.matrix     :as m]
            [magellan.core           :refer [read-raster]]
            [magellan.raster.inspect :as inspect]))

(defn geotiff-raster-to-matrix
  "Reads a raster from a file using the magellan.core library. Returns the
   post-processed raster values as a Clojure matrix using the core.matrix API
   along with all of the georeferencing information associated with this tile in a
   hash-map with the following form:
  {:srid 900916,
   :upperleftx -321043.875,
   :upperlefty -1917341.5,
   :width 486,
   :height 534,
   :scalex 2000.0,
   :scaley -2000.0,
   :skewx 0.0,
   :skewy 0.0,
   :numbands 10,
   :matrix #vectorz/matrix Large matrix with shape: [10,534,486]}"
  [file-path]
  (let [raster   (read-raster file-path)
        grid     (:grid raster)
        r-info   (inspect/describe-raster raster)
        matrix   (inspect/extract-matrix raster)
        image    (:image r-info)
        envelope (:envelope r-info)]
    {:srid       (:srid r-info)
     :upperleftx (get-in envelope [:x :min])
     :upperlefty (get-in envelope [:y :min])
     :width      (:width image)
     :height     (:height image)
     :scalex     (.getScaleX (.getGridToCRS2D grid))
     :scaley     (.getScaleY (.getGridToCRS2D grid))
     :skewx      0.0 ;FIXME not used?
     :skewy      0.0 ;FIXME not used?
     :numbands   (:bands image)
     :matrix     (m/matrix matrix)}))
#+end_src

** Command Line Interface

The entire GridFire system is available for use directly from the
Clojure REPL. This enables straightforward analysis and introspection
of the fire behavior functions and their results over a range of
inputs. However, if you just want to simulate an individual
ignition event, GridFire comes with a simple command line interface
that can be parameterized by a single configuration file, specifying
the ignition location, burn duration, weather values, and the location
of the PostGIS raster layers to use for topography and fuels.

The executable may be created using the Clojure CLI tools as follows:

#+name: build-jar
#+begin_src sh :results silent :exports code
clojure -A:make-uberjar
#+end_src

This command will generate a Java Archive (JAR) file in
the *target* directory that may be run from the command line as
follows:

#+name: run-gridfire-jar
#+begin_src sh :results silent :exports code
java -jar gridfire-<version>.jar myconfig.edn
#+end_src

When run, the executable connects to the PostGIS database specified in
the passed-in config file, downloads the necessary raster layers,
simulates the ignition event for the requested duration, and returns
2D maps showing the spatial distributions of fire spread, flame
length, and fire line intensity respectively. Finally, it prints out
the final clock time from when the simulation was terminated as well
as the total number of ignited cells on the raster grid at that point.

Which maps are created (and in what formats) may be configured by
setting the following options in GridFire's input config file to true
or false:

#+ATTR_LATEX: :options \setlength{\itemsep}{-3mm}
1. :output-landfire-inputs?
2. :output-geotiffs?
3. :output-pngs?

#+name: command-line-interface
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/cli.clj :padline no :no-expand :comments link
(ns gridfire.cli
  (:gen-class)
  (:require [clojure.core.matrix   :as m]
            [clojure.data.csv      :as csv]
            [clojure.edn           :as edn]
            [clojure.java.io       :as io]
            [clojure.spec.alpha    :as s]
            [clojure.string        :as str]
            [gridfire.common :refer [in-bounds?]]
            [gridfire.crown-fire   :refer [m->ft]]
            [gridfire.fetch        :as fetch]
            [gridfire.fire-spread  :refer [get-neighbors run-fire-spread]]
            [gridfire.perturbation :as perturbation]
            [gridfire.spec.config  :as spec]
            [gridfire.utils.random :refer [my-rand-int my-rand-nth]]
            [magellan.core         :refer [make-envelope
                                           matrix-to-raster
                                           register-new-crs-definitions-from-properties-file!
                                           write-raster]]
            [matrix-viz.core       :refer [save-matrix-as-png]])
  (:import java.util.Random))

(m/set-current-implementation :vectorz)

(register-new-crs-definitions-from-properties-file! "CUSTOM"
                                                    (io/resource "custom_projections.properties"))

(defn sample-from-list
  [rand-generator n xs]
  (repeatedly n #(my-rand-nth rand-generator xs)))

(defn sample-from-range
  [rand-generator n [min max]]
  (let [range (- max min)]
    (repeatedly n #(+ min (my-rand-int rand-generator range)))))

(defn draw-samples
  [rand-generator n x]
  (into []
        (cond (list? x)   (sample-from-list rand-generator n x)
              (vector? x) (sample-from-range rand-generator n x)
              :else       (repeat n x))))

(defn cells-to-acres
  [cell-size num-cells]
  (let [acres-per-cell (/ (* cell-size cell-size) 43560.0)]
    (* acres-per-cell num-cells)))

(defn summarize-fire-spread-results
  [fire-spread-results cell-size]
  (let [flame-lengths              (filterv pos? (m/eseq (:flame-length-matrix fire-spread-results)))
        fire-line-intensities      (filterv pos? (m/eseq (:fire-line-intensity-matrix fire-spread-results)))
        burned-cells               (count flame-lengths)
        fire-size                  (cells-to-acres cell-size burned-cells)
        flame-length-mean          (/ (m/esum flame-lengths) burned-cells)
        fire-line-intensity-mean   (/ (m/esum fire-line-intensities) burned-cells)
        flame-length-stddev        (->> flame-lengths
                                        (m/emap #(Math/pow (- flame-length-mean %) 2.0))
                                        (m/esum)
                                        (#(/ % burned-cells))
                                        (Math/sqrt))
        fire-line-intensity-stddev (->> fire-line-intensities
                                        (m/emap #(Math/pow (- fire-line-intensity-mean %) 2.0))
                                        (m/esum)
                                        (#(/ % burned-cells))
                                        (Math/sqrt))]
    {:fire-size                  fire-size
     :flame-length-mean          flame-length-mean
     :flame-length-stddev        flame-length-stddev
     :fire-line-intensity-mean   fire-line-intensity-mean
     :fire-line-intensity-stddev fire-line-intensity-stddev}))

(defn calc-emc
  "Computes the Equilibrium Moisture Content (EMC) from rh (relative
   humidity in %) and temp (temperature in F)."
  [rh temp]
  (/ (cond (< rh 10)  (+ 0.03229 (* 0.281073 rh) (* -0.000578 rh temp))
           (< rh 50)  (+ 2.22749 (* 0.160107 rh) (* -0.01478 temp))
           :otherwise (+ 21.0606 (* 0.005565 rh rh) (* -0.00035 rh temp) (* -0.483199 rh)))
     30))

(defn calc-ffwi
  "Computes the Fosberg Fire Weather Index value from rh (relative
   humidity in %), temp (temperature in F), wsp (wind speed in mph),
   and a constant x (gust multiplier).
   ------------------------------------------------------------------
   Note: ffwi can be computed with (calc-ffwi rh temp wsp 1.0)
         ffwi-max can be computed with (calc-ffwi minrh maxtemp wsp 1.75)
   Geek points: Uses Cramer's rule: (+ d (* x (+ c (* x (+ b (* x a))))))
                for an efficient cubic calculation on tmp."
  [rh temp wsp x]
  (let [m   (calc-emc rh temp)
        eta (+ 1 (* m (+ -2 (* m (+ 1.5 (* m -0.5))))))]
    (/ (* eta (Math/sqrt (+ 1 (Math/pow (* x wsp) 2))))
       0.3002)))

(defn kebab->snake [s]
  (str/replace s #"-" "_"))

(defn snake->kebab [s]
  (str/replace s #"_" "-"))

(defn min->hour [t]
  (int (quot t 60)))

(defn previous-active-perimeter?
  [[i j :as here] matrix]
  (let [num-rows (m/row-count matrix)
        num-cols (m/column-count matrix)]
   (and
    (= (m/mget matrix i j) -1.0)
    (->> (get-neighbors here)
         (filter #(in-bounds? num-rows num-cols %))
         (map #(apply m/mget matrix %))
         (some pos?)))))

(defn to-color-map-values [burn-time-matrix current-clock]
  (m/emap-indexed (fn [here burn-time]
                    (let [delta-hours (->> (- current-clock burn-time)
                                           min->hour)]
                      (cond
                        (previous-active-perimeter? here burn-time-matrix) 201
                        (= burn-time -1.0)                                 200
                        (< 0 delta-hours 5)                                delta-hours
                        (>= delta-hours 5)                                 5
                        :else                                              0)))
                  burn-time-matrix))

(defn layer-snapshot [burn-time-matrix layer-matrix t]
  (m/emap (fn [layer-value burn-time]
            (if (<= burn-time t)
              layer-value
              0))
          layer-matrix
          burn-time-matrix))

(defn output-filename [name outfile-suffix simulation-id output-time ext]
  (as-> [name outfile-suffix simulation-id (when output-time (str "t" output-time))] $
       (remove str/blank? $)
       (str/join "_" $)
       (str $ ext)))

(defn output-geotiff
  ([config matrix name envelope]
   (output-geotiff config matrix name envelope nil nil))

  ([config matrix name envelope simulation-id]
   (output-geotiff config matrix name envelope simulation-id nil))

  ([{:keys [output-geotiffs? outfile-suffix] :as config}
    matrix name envelope simulation-id output-time]
   (when output-geotiffs?
     (-> (matrix-to-raster name matrix envelope)
         (write-raster (output-filename name
                                        outfile-suffix
                                        (str simulation-id)
                                        output-time
                                        ".tif"))))))

(defn output-png
  ([config matrix name envelope]
   (output-png config matrix name envelope nil nil))

  ([config matrix name envelope simulation-id]
   (output-png config matrix name envelope simulation-id nil))

  ([{:keys [output-png? outfile-suffix] :as config}
    matrix name envelope simulation-id output-time]
   (when output-png?
     (save-matrix-as-png :color 4 -1.0
                         matrix
                         (output-filename name
                                          outfile-suffix
                                          (str simulation-id)
                                          output-time
                                          ".png")))))

(def layer-name->matrix
  [["fire_spread"         :fire-spread-matrix]
   ["flame_length"        :flame-length-matrix]
   ["fire_line_intensity" :fire-line-intensity-matrix]
   ["burn_history"        :burn-time-matrix]])

(defn filter-output-layers [output-layers]
  (let [layers-to-filter (set (map (comp kebab->snake name) (keys output-layers)))]
    (filter (fn [[name _]] (contains? layers-to-filter name)) layer-name->matrix)))

(defn process-output-layers-timestepped
  [{:keys [simulation-id] :as config}
   {:keys [global-clock burn-time-matrix] :as fire-spread-results}
   name layer timestep envelope]
  (doseq [output-time (range 0 (inc global-clock) timestep)]
    (let [matrix          (if (= layer "burn_history")
                            (to-color-map-values layer output-time)
                            (fire-spread-results layer))
          filtered-matrix (layer-snapshot burn-time-matrix matrix output-time)]
      (output-geotiff config filtered-matrix name envelope simulation-id output-time)
      (output-png config filtered-matrix name envelope simulation-id output-time))))

(defn process-output-layers!
  [{:keys [output-layers] :as config}
   {:keys [global-clock burn-time-matrix] :as fire-spread-results}
   envelope
   simulation-id]
  (let [layers (if output-layers
                 (filter-output-layers output-layers)
                 layer-name->matrix)]
    (doseq [[name layer] layers]
      (let [kw       (keyword (snake->kebab name))
            timestep (get output-layers kw)]
        (if (int? timestep)
          (process-output-layers-timestepped config
                                             fire-spread-results
                                             name
                                             layer
                                             timestep
                                             envelope)
          (let [matrix (if (= layer "burn_history")
                         (to-color-map-values layer global-clock)
                         (fire-spread-results layer))]
            (output-geotiff config matrix name envelope simulation-id)
            (output-png config matrix name envelope simulation-id)))))))

(defn process-burn-count!
  [{:keys [fire-spread-matrix burn-time-matrix global-clock]}
   burn-count-matrix
   timestep]
  (if (int? timestep)
   (doseq [clock (range 0 (inc global-clock) timestep)]
     (let [filtered-fire-spread (m/emap (fn [layer-value burn-time]
                                          (if (<= burn-time clock)
                                            layer-value
                                            0))
                                        fire-spread-matrix
                                        burn-time-matrix)
           band                 (int (quot clock timestep))]
       (m/add! (nth (seq burn-count-matrix) band) filtered-fire-spread)))
   (m/add! burn-count-matrix fire-spread-matrix)))

(defn output-burn-probability-layer!
  [{:keys [output-burn-probability simulations] :as config} envelope burn-count-matrix]
  (when-let [timestep output-burn-probability]
    (let [output-name "burn_probability"]
      (if (int? timestep)
        (doseq [[band matrix] (map-indexed vector burn-count-matrix)]
          (let [output-time        (* band timestep)
                probability-matrix (m/emap #(/ % simulations) matrix)]
            (output-geotiff config probability-matrix output-name envelope nil output-time)
            (output-png config probability-matrix output-name envelope nil output-time)))
        (let [probability-matrix (m/emap #(/ % simulations) burn-count-matrix)]
          (output-geotiff config probability-matrix output-name envelope)
          (output-png config probability-matrix output-name envelope))))))

(defn initialize-burn-count-matrix
  [{:keys [output-burn-probability]} max-runtime num-rows num-cols]
  (when output-burn-probability
    (if (int? output-burn-probability)
     (let [num-bands (inc (quot (apply max max-runtime) output-burn-probability))]
       (m/zero-array [num-bands num-rows num-cols]))
     (m/zero-array [num-rows num-cols]))))

(defn run-simulations
  [{:keys
    [cell-size output-csvs? simulations output-layers output-burn-probability] :as config}
   landfire-rasters envelope ignition-row ignition-col max-runtime temperature
   relative-humidity wind-speed-20ft wind-from-direction foliar-moisture
   ellipse-adjustment-factor ignition-layer multiplier-lookup perturbations
   burn-count-matrix]
  (mapv
   (fn [i]
     (let [initial-ignition-site (or ignition-layer
                                     [(ignition-row i) (ignition-col i)])
           temperature           (if (map? temperature) (:matrix temperature) (temperature i))
           wind-speed-20ft       (if (map? wind-speed-20ft) (:matrix wind-speed-20ft) (wind-speed-20ft i))
           wind-from-direction   (if (map? wind-from-direction) (:matrix wind-from-direction) (wind-from-direction i))
           relative-humidity     (if (map? relative-humidity) (:matrix relative-humidity) (relative-humidity i))]
       (if-let [fire-spread-results (run-fire-spread
                                     {:max-runtime               (max-runtime i)
                                      :cell-size                 cell-size
                                      :landfire-rasters          landfire-rasters
                                      :wind-speed-20ft           wind-speed-20ft
                                      :wind-from-direction       wind-from-direction
                                      :temperature               temperature
                                      :relative-humidity         relative-humidity
                                      :foliar-moisture           (* 0.01 (foliar-moisture i))
                                      :ellipse-adjustment-factor (ellipse-adjustment-factor i)
                                      :num-rows                  (m/row-count (:fuel-model landfire-rasters))
                                      :num-cols                  (m/column-count (:fuel-model landfire-rasters))
                                      :multiplier-lookup         multiplier-lookup
                                      :initial-ignition-site     initial-ignition-site
                                      :firebrand-count           (:firebrand-count config)
                                      :perturbations             (when perturbations
                                                                   (perturbations i))
                                      :spotting                  (:spotting config)}
                                     config)]
         (do
           (process-output-layers! config fire-spread-results envelope i)
           (when-let [timestep output-burn-probability]
             (process-burn-count! fire-spread-results burn-count-matrix timestep))
           (if output-csvs?
             (merge
              {:ignition-row              (ignition-row i)
               :ignition-col              (ignition-col i)
               :max-runtime               (max-runtime i)
               :temperature               temperature
               :relative-humidity         relative-humidity
               :wind-speed-20ft           wind-speed-20ft
               :wind-from-direction       wind-from-direction
               :foliar-moisture           (foliar-moisture i)
               :ellipse-adjustment-factor (ellipse-adjustment-factor i)
               :exit-condition            (:exit-condition fire-spread-results)}
              (summarize-fire-spread-results fire-spread-results cell-size))))
         (when output-csvs?
           {:ignition-row               (ignition-row i)
            :ignition-col               (ignition-col i)
            :max-runtime                (max-runtime i)
            :temperature                temperature
            :relative-humidity          relative-humidity
            :wind-speed-20ft            wind-speed-20ft
            :wind-from-direction        wind-from-direction
            :foliar-moisture            (foliar-moisture i)
            :ellipse-adjustment-factor  (ellipse-adjustment-factor i)
            :fire-size                  0.0
            :flame-length-mean          0.0
            :flame-length-stddev        0.0
            :fire-line-intensity-mean   0.0
            :fire-line-intensity-stddev 0.0
            :exit-condition             :no-fire-spread}))))
   (range simulations)))

(defn write-csv-outputs
  [output-csvs? output-filename results-table]
  (when output-csvs?
    (with-open [out-file (io/writer output-filename)]
      (->> results-table
           (sort-by #(vector (:ignition-row %) (:ignition-col %)))
           (mapv (fn [{:keys [ignition-row ignition-col max-runtime temperature relative-humidity wind-speed-20ft
                              wind-from-direction foliar-moisture ellipse-adjustment-factor fire-size flame-length-mean
                              flame-length-stddev fire-line-intensity-mean fire-line-intensity-stddev]}]
                   [ignition-row
                    ignition-col
                    max-runtime
                    temperature
                    relative-humidity
                    wind-speed-20ft
                    wind-from-direction
                    foliar-moisture
                    ellipse-adjustment-factor
                    fire-size
                    flame-length-mean
                    flame-length-stddev
                    fire-line-intensity-mean
                    fire-line-intensity-stddev]))
           (cons ["ignition-row" "ignition-col" "max-runtime" "temperature" "relative-humidity" "wind-speed-20ft"
                  "wind-from-direction" "foliar-moisture" "ellipse-adjustment-factor" "fire-size" "flame-length-mean"
                  "flame-length-stddev" "fire-line-intensity-mean" "fire-line-intensity-stddev"])
           (csv/write-csv out-file)))))

(defn get-envelope
  [config landfire-layers]
  (let [{:keys [upperleftx upperlefty width height scalex scaley]} (landfire-layers :elevation)]
    (make-envelope (:srid config)
                   upperleftx
                   (+ upperlefty (* height scaley))
                   (* width scalex)
                   (* -1.0 height scaley))))

(defn get-weather [config rand-generator weather-type weather-layers]
  (if (contains? weather-layers weather-type)
    (weather-type weather-layers)
    (draw-samples rand-generator (:simulations config) (config weather-type))))

(defn create-multiplier-lookup
  [{:keys [cell-size]} weather-layers]
  (reduce-kv (fn [acc k {:keys [scalex]}]
               (assoc acc k (int (quot (m->ft scalex) cell-size))))
             {}
             weather-layers))

(defn -main
  [& config-files]
  (doseq [config-file config-files]
    (let [config (edn/read-string (slurp config-file))]
      (if (s/valid? ::spec/config config)
        (let [landfire-layers   (fetch/landfire-layers config)
              landfire-rasters  (into {}
                                      (map (fn [[layer info]] [layer (first (:matrix info))]))
                                      landfire-layers)
              ignition-layer    (fetch/ignition-layer config)
              weather-layers    (fetch/weather-layers config)
              multiplier-lookup (create-multiplier-lookup config weather-layers)
              envelope          (get-envelope config landfire-layers)
              simulations       (:simulations config)
              rand-generator    (if-let [seed (:random-seed config)]
                                  (Random. seed)
                                  (Random.))
              max-runtimes      (draw-samples rand-generator simulations (:max-runtime config))
              num-rows          (m/row-count (:fuel-model landfire-rasters))
              num-cols          (m/column-count (:fuel-model landfire-rasters))
              burn-count-matrix (initialize-burn-count-matrix config max-runtimes num-rows num-cols)]
          (when (:output-landfire-inputs? config)
            (doseq [[layer matrix] landfire-rasters]
              (-> (matrix-to-raster (name layer) matrix envelope)
                  (write-raster (str (name layer) (:outfile-suffix config) ".tif")))))
          (->> (run-simulations
                (assoc config :rand-gen rand-generator)
                landfire-rasters
                envelope
                (draw-samples rand-generator simulations (:ignition-row config))
                (draw-samples rand-generator simulations (:ignition-col config))
                max-runtimes
                (get-weather config rand-generator :temperature weather-layers)
                (get-weather config rand-generator :relative-humidity weather-layers)
                (get-weather config rand-generator :wind-speed-20ft weather-layers)
                (get-weather config rand-generator :wind-from-direction weather-layers)
                (draw-samples rand-generator simulations (:foliar-moisture config))
                (draw-samples rand-generator simulations (:ellipse-adjustment-factor config))
                ignition-layer
                multiplier-lookup
                (perturbation/draw-samples rand-generator simulations (:perturbations config))
                burn-count-matrix)
               (write-csv-outputs
                (:output-csvs? config)
                (str "summary_stats" (:outfile-suffix config) ".csv")))
          (output-burn-probability-layer! config envelope burn-count-matrix))
        (s/explain ::spec/config config)))))
#+end_src

#+name: utils-random
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/utils/random.clj :padline no :no-expand :comments link
(ns gridfire.utils.random
  (:import java.util.Random))

(defn my-rand
  ([^Random rand-generator] (.nextDouble rand-generator))
  ([^Random rand-generator n] (* n (my-rand rand-generator))))

(defn my-rand-int
  [rand-generator n]
  (int (my-rand rand-generator n)))

(defn my-rand-nth
  [rand-generator coll]
  (nth coll (my-rand-int rand-generator (count coll))))

(defn random-float
  [min-val max-val rand-generator]
  (let [range (- max-val min-val)]
    (+ min-val (my-rand rand-generator range))))
#+end_src

* Configuration File

The configuration file for GridFire's command line interface is a text
file in Extensible Data Notation (EDN) format.[fn::
https://github.com/edn-format/edn] A sample configuration file is
provided below and in ``resources/sample_config.edn''. The format
should be self-evident at a glance, but it is worth noting that EDN is
case-sensitive but whitespace-insensitive. Comments are anything
following two semi-colons (;;). Strings are contained in double-quotes
(``''). Keywords are prefixed with a colon (:). Vectors are delimited
with square brackets ([]). Associative lookup tables (a.k.a. maps) are
delimited with curly braces ({}) and are used to express key-value
relationships.

The configuration file can be broken up into 5 sections as described
below:

** Section 1: Landscape data to be shared by all simulations

GridFire allows us to choose how we want to ingest landscape data
through the configuration file. We can choose to get LANDFIRE layers
from our PostGIS database, or we can read raster files from disk. This
behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *landfire-layers*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

To fetch layers from a Postgresql database you must also include the
follwing mapping:

- *db-spec*: a map of database connection information for our Postgresql
  database

Here's an example of fetching LANDFIRE layers from a Postgresql database.
#+begin_src clojure
{:db-spec            {:classname   "org.postgresql.Driver"
                      :subprotocol "postgresql"
                      :subname     "//localhost:5432/gridfire"
                      :user        "gridfire"}
 :landfire-layers    {:aspect             {:type   :postgis
                                           :source "landfire.asp WHERE rid=100"}
                      :canopy-base-height {:type   :postgis
                                           :source "landfire.cbh WHERE rid=100"}
                      :canopy-cover       {:type   :postgis
                                           :source "landfire.cc WHERE rid=100"}
                      :canopy-height      {:type   :postgis
                                           :source "landfire.ch WHERE rid=100"}
                      :crown-bulk-density {:type   :postgis
                                           :source "landfire.cbd WHERE rid=100"}
                      :elevation          {:type   :postgis
                                           :source "landfire.fbfm40 WHERE rid=100"}
                      :fuel-model         {:type   :postgis
                                           :source "landfire.slp WHERE rid=100"}
                      :slope              {:type   :postgis
                                           :source "landfire.dem WHERE rid=100"}}}
#+end_src

Here's an example of fetching LANDFIRE layers from files on disk.
#+begin_src clojure
{:landfire-layers {:aspect             {:type   :geotiff
                                        :source "test/gridfire/resources/asp.tif"}
                   :canopy-base-height {:type   :geotiff
                                        :source "test/gridfire/resources/cbh.tif"}
                   :canopy-cover       {:type   :geotiff
                                        :source "test/gridfire/resources/cc.tif"}
                   :canopy-height      {:type   :geotiff
                                        :source "test/gridfire/resources/ch.tif"}
                   :crown-bulk-density {:type   :geotiff
                                        :source "test/gridfire/resources/cbd.tif"}
                   :elevation          {:type   :geotiff
                                        :source "test/gridfire/resources/dem.tif"}
                   :fuel-model         {:type   :geotiff
                                        :source "test/gridfire/resources/fbfm40.tif"}
                   :slope              {:type   :geotiff
                                        :source "test/gridfire/resources/slp.tif"}}}
#+end_src

Include the following required mapping on all configurations:

#+begin_src clojure
{:srid      "CUSTOM:900914"
 :cell-size 98.425} ; (feet)
#+end_src

** Section 2: Ignition data from which to build simulation inputs

GridFire allows us to choose how we want to initialize the ignition
area. We can choose one of 2 options: to initialize a single point or
an existing burn perimeter (raster).

To initialize a single point, include the following mappings:

- *ignition-row*: (single, list, or range of values)
- *ignition-col*: (single, list, or range of values)

For this method of ignition, values may be entered in one of three ways:

1. If a single value is provided, it will be kept the same for all
   simulations.
2. For a list of values, a value from the list will be randomly
   selected in each simulation.
3. For a range of values, a value from the range [inclusive exclusive]
   will be randomly selected in each simulation.

#+begin_src clojure
{:ignition-row [10 90]
 :ignition-col [20 80]}
#+end_src

To initialize an existing burn perimeter from a raster, we have two
options. We can read rasters from a Postgresql database or a raster
file on disk. This behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *ignition-layer*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

Here's an example of fetching an intial burn perimeter from a
Postgresql database.

*Note*: be sure to include the map of database connection (*:db-spec*) as
described in section 1.
#+begin_src clojure
{:ignition-layer {:type   :postgis
                  :source "ignition.ign WHERE rid=1"}}
#+end_src

Here's an example of fetching an intial burn perimeter from a file on
disk
#+begin_src clojure
{:fetch-ignition-method :geotiff
 :ignition-layer        "test/gridfire/resources/ign.tif"}
#+end_src

GridFire makes use of clojure's multimethods to dispatch control to
different handlers for fetching ignition layers. The dispatch depends
on what is in the config file. Here's the namespace that implements
this functionality.

#+name: fetch.clj
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/fetch.clj :padline no :no-expand :comments link
(ns gridfire.fetch
  (:require [clojure.core.matrix      :as m]
            [gridfire.magellan-bridge :refer [geotiff-raster-to-matrix]]
            [gridfire.postgis-bridge  :refer [postgis-raster-to-matrix]]
            [gridfire.spec.config     :as spec]
            [gridfire.surface-fire    :refer [degrees-to-radians]]))

;;-----------------------------------------------------------------------------
;; LANDFIRE
;;-----------------------------------------------------------------------------

(def layer-names
  [:aspect
   :canopy-base-height
   :canopy-cover
   :canopy-height
   :crown-bulk-density
   :elevation
   :fuel-model
   :slope])

(defn convert-metrics
  "Converting metrics in layers:
  meters to feet
  degrees to percent"
  [landfire-layers]
  (-> landfire-layers
      (update-in [:elevation :matrix]
                 (fn [matrix] (m/emap #(* % 3.28) matrix))) ; m -> ft
      (update-in [:slope :matrix]
                 (fn [matrix] (m/emap #(Math/tan (degrees-to-radians %)) matrix))) ; degrees -> %
      (update-in [:canopy-height :matrix]
                 (fn [matrix] (m/emap #(* % 3.28) matrix))) ; m -> ft
      (update-in [:canopy-base-height :matrix]
                 (fn [matrix] (m/emap #(* % 3.28) matrix))) ; m -> ft
      (update-in [:crown-bulk-density :matrix]
                 (fn [matrix] (m/emap #(* % 0.0624) matrix))))) ; kg/m^3 -> lb/ft^3

(defmulti landfire-layer
  (fn [_ {:keys [type]}] type))

(defmethod landfire-layer :postgis
  [db-spec {:keys [source]}]
  (postgis-raster-to-matrix db-spec source))

(defmethod landfire-layer :geotiff
  [_ {:keys [source]}]
  (geotiff-raster-to-matrix source))

(defn landfire-layers
  "Returns a map of LANDFIRE rasters (represented as maps) with the following units:
   {:elevation          feet
    :slope              vertical feet/horizontal feet
    :aspect             degrees clockwise from north
    :fuel-model         fuel model numbers 1-256
    :canopy-height      feet
    :canopy-base-height feet
    :crown-bulk-density lb/ft^3
    :canopy-cover       % (0-100)}"
  [{:keys [db-spec] :as config}]
  (convert-metrics
   (let [layers (:landfire-layers config)]
     (reduce (fn [amap layer-name]
               (let [source (get layers layer-name)]
                 (assoc amap
                        layer-name
                        (if (map? source)
                          (landfire-layer db-spec source)
                          (postgis-raster-to-matrix db-spec source)))))
             {}
             layer-names))))

;;-----------------------------------------------------------------------------
;; Initial Ignition
;;-----------------------------------------------------------------------------

(defn convert-burn-values [matrix {:keys [burned unburned]}]
  (m/emap #(condp = %
             (double burned)   1.0
             (double unburned) 0.0
             -1.0)
          matrix))

(defmulti ignition-layer
  (fn [{:keys [ignition-layer]}] (:type ignition-layer)))

(defmethod ignition-layer :postgis
  [{:keys [db-spec ignition-layer]}]
  (let [layer (postgis-raster-to-matrix db-spec (:source ignition-layer))]
    (if-let [bv (:burn-values ignition-layer)]
      (assoc layer :matrix (convert-burn-values (:matrix layer) bv))
      layer)))

(defmethod ignition-layer :geotiff
  [{:keys [ignition-layer]}]
  (let [layer (geotiff-raster-to-matrix (:source ignition-layer))]
    (if-let [bv (:burn-values ignition-layer)]
      (assoc layer :matrix (convert-burn-values (:matrix layer) bv))
      layer)))

(defmethod ignition-layer :default
  [_]
  nil)

;;-----------------------------------------------------------------------------
;; Weather
;;-----------------------------------------------------------------------------

(defmulti weather
  (fn [_ {:keys [type]}] type))

(defmethod weather :postgis
  [{:keys [db-spec]} {:keys [source]}]
  (postgis-raster-to-matrix db-spec source))

(defmethod weather :geotiff
  [_ {:keys [source]}]
  (geotiff-raster-to-matrix source))

(defn weather-layers
  "Returns a map of weather layers (represented as maps) with the following units:
   {:temperature         farenheight
    :relative-humidity   %
    :wind-speed-20ft     mph
    :wind-from-direction degrees clockwise from north}"
  [config]
  (reduce (fn [acc weather-name]
            (let [weather-spec (weather-name config)]
              (if (map? weather-spec)
                (assoc acc weather-name (weather config weather-spec))
                acc)))
          {}
          spec/weather-names))
#+end_src

** Section 3: Weather data from which to build simulation inputs

For all the options in this section, you may enter values in one of
three ways (as described in section 2): single, list, or range of
values.

#+begin_src clojure
{:temperature               (50 65 80)     ; (degrees Fahrenheit)
 :relative-humidity         (1 10 20)      ; (%)
 :wind-speed-20ft           (10 15 20)     ; (miles/hour)
 :wind-from-direction       (0 90 180 270) ; (degrees clockwise from north)
 :foliar-moisture           90}            ; (%)
#+end_src

Temperature, relative humidity, wind speed, and wind direction accepts
an additional type of input. GridFire allows us to use weather data
from rasters. To use weather data from raster we have two options.
This behavior is controlled as follows:

Include the following mapping at the top level of the configuraiton
file:

- *[weather-type]*: a map of fetch specifications

For the fetch specifications include the following mappings:
- *type*: the method for fetching the layer
- *source*: the string input for the fetch method

Here's an example of fetching weather rasters from a Postgresql database.
*Note*: be sure to include the map of database connection (*:db-spec*) as
described in section 1.
#+begin_src clojure
{:temperature         {:type   :postgis
                       :source "weather.tmpf WHERE rid=100"}
 :relative-humidity   {:type   :postgis
                       :source "weather.rh WHERE rid=100"}
 :wind-speed-20ft     {:type   :postgis
                       :source "weather.ws WHERE rid=100"}
 :wind-from-direction {:type   :postgis
                       :source "weather.wd WHERE rid=100"}}
#+end_src

Here's an example of fetching weather rasters from files on disk.
#+begin_src clojure
{:temperature         {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/tmpf_to_sample.tif"}
 :relative-humidity   {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/rh_to_sample.tif"}
 :wind-speed-20ft     {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/ws_to_sample.tif"}
 :wind-from-direction {:type   :geotiff
                       :source "test/gridfire/resources/weather-test/d_to_sample.tif"}}
#+end_src

*NOTE:* Gridfire expects weather raster's resolution and the landfire's
resolution as designated by the `:cell-size` must be exact multiples
of one another. This means you may choose to use raster's of different
cell sizes to improve preformance.

** Section 4: Number of simulations and (optional) random seed perimeter

#+begin_src clojure
{:max-runtime               60             ; (minutes)
 :simulations               10
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :random-seed 1234567890}                  ; long value (optional)
#+end_src

** Section 5: Outputs

Currently supported Geotiff layers for output
- fire-spread
- flame-length
- fire-line-intensity
- burn-history

To control the layers to output include the following mappings:
- *output-layers*: map of layers-name to timestep (in minutes) or the keyword `:final`
- *output-geotiff*: boolean

#+begin_src clojure
{:output-layers  {:fire-spread  10
                  :burn-history :final}
 :output-geotiff true}
#+end_src

The configuration above specify that we'd like to output one
firespread geotiff every 10 minutes in the simulation. For the burn
history we'd like to output the geotiff file at the final timestep of
the simulation. 

*Note:* if entry for `:output-layers` is omitted but `:output-geotiff`
is set to true then Gridfire will output all layers above at the final
timestep. 

Gridfire also supports an output for the burn probability layer which
is a matrix of the probability of a cell being burned across all
simulations. To control the output of the burn probability layer
include the following mapping:

- *output-*burn-probability*: timestep (in minutes) or keyword `:final`

#+begin_src clojure
{:output-burn-probability 10
 :output-geotiff          true}
#+end_src

Other output mappings:

#+begin_src clojure
{:outfile-suffix          "_tile_100"
 :output-landfire-inputs? true
 :output-pngs?            true
 :output-csvs?            true}
#+end_src

** Section 6: Perturbations

Gridfire supports puturbations of input rasters during simulations in
order to account for inherent uncertainty in the data. A uniform
random sampling of values within a given range is used to address
these uncertanties. 

To specify this in the config file include the following mappings:

- *perturbations:* a map of layer names to a map of perturbation configurations

#+begin_src clojure
{:perturbations {:canopy-height {:spatial-type :global
                                 :range        [-1.0 1.0]}}}
#+end_src

The above config specify that a randomly selected value between -1.0
and 1.0 should be added to the canopy height value. This perturbation
will be applied globally to all cells. We could also, instead, specify
that each cell should be perturbed individually by setting spatial
type to *:pixel*.

 #+name: perturbation
#+begin_src clojure :results silent :exports code :tangle ../src/gridfire/perturbation.clj :padline no :no-expand :comments link
(ns gridfire.perturbation
  (:require [gridfire.utils.random :refer [random-float]]))

(defn- enrich-info
  [perturbations rand-generator id]
  (reduce-kv
   (fn [acc k {:keys [spatial-type range rand-gen] :as v}]
     (let [simulation-id     id
           [min-val max-val] range]
       (if (= spatial-type :global)
         (update-in acc [k] merge {:global-value   (random-float min-val max-val rand-generator)
                                   :simulation-id  simulation-id
                                   :rand-generator rand-generator})
         (update-in acc [k] merge {:simulation-id  simulation-id
                                   :rand-generator rand-generator}))))
   perturbations
   perturbations))

(defn draw-samples
  [rand-generator n perturbations]
  (when perturbations
    (mapv #(enrich-info perturbations rand-generator %) (range n))))

(defn value-at
  ([perturb-info raster here]
   (value-at perturb-info raster here nil))

  ([{:keys [range spatial-type global-value rand-generator]} raster here frequency-band]
   (let [[min-val max-val] range]
     (if (= spatial-type :global)
       global-value
       (random-float min-val max-val rand-generator)))))

(def value-at
  (memoize value-at))

(defn- update?
  [global-clock next-clock frequency]
  (< (quot global-clock frequency)
     (quot next-clock frequency)))

(defn- global-temporal-perturbations
  [perturbations]
  (->> perturbations
       (filter (fn [[k v]] (and (:frequency v) (= (:spatial-type v) :global))))
       keys))

(defn update-global-vals
  [{:keys [perturbations] :as constants} current-clock next-clock]
  (let [layers-to-update (global-temporal-perturbations perturbations)]
    (reduce
     (fn [acc layer-name]
       (let [{:keys [frequency
                     range
                     rand-generator]} (get-in acc [:perturbations layer-name])
             [min-val max-val]        range
             new-global               (random-float min-val max-val rand-generator)]
         (if (update? current-clock next-clock frequency)
           (assoc-in acc [:perturbations layer-name :global-value] new-global)
           acc)))
     constants
     layers-to-update)))
#+end_src

* Example Configuration files

Here is a complete sample configuration for using landfire layers from our postigs enabled
database and initializing burn points from a range of values.

Here is a complete sample configuration for using LANDFIRE layers from
our PostGIS-enabled database with ignition points randomly sampled
from a range.

#+name: sample_postgis_config.edn
#+begin_src clojure :results silent :exports code :tangle ../resources/sample_postgis_config.edn :padline no :no-expand :comments link
{;; Section 1: Landscape data to be shared by all simulations
 :fetch-layer-method        :postgis
 :db-spec                   {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//localhost:5432/gridfire"
                             :user        "gridfire"
                             :password    "gridfire"}
 :landfire-layers            {:aspect             {:type   :postgis
                                                   :source "landfire.asp WHERE rid=100"}
                              :canopy-base-height {:type   :postgis
                                                   :source "landfire.cbh WHERE rid=100"}
                              :canopy-cover       {:type   :postgis
                                                   :source "landfire.cc WHERE rid=100"}
                              :canopy-height      {:type   :postgis
                                                   :source "landfire.ch WHERE rid=100"}
                              :crown-bulk-density {:type   :postgis
                                                   :source "landfire.cbd WHERE rid=100"}
                              :elevation          {:type   :postgis
                                                   :source "landfire.fbfm40 WHERE rid=100"}
                              :fuel-model         {:type   :postgis
                                                   :source "landfire.slp WHERE rid=100"}
                              :slope              {:type   :postgis
                                                   :source "landfire.dem WHERE rid=100"}}
 :srid                      "CUSTOM:900914"
 :cell-size                 98.425         ; (feet)

 ;; Section 2: Ignition data from which to build simulation inputs
 :ignition-row              [10 90]
 :ignition-col              [20 80]

 ;; Section 3: Weather data from which to build simulation inputs
 ;; For all options in this section, you may enter values in one of three ways:
 ;;   1. Single Value: 25
 ;;   2. List of Values: (2 17 9)
 ;;   3. Range of Values: [10 20]
 ;;   4. Raster from file on disk: {:type :geotiff :source "path/to/file/weather.tif"}
 ;;   5. Raster from Postgresql database: {:type :postgis :source "weather.ws WHERE rid=1"}
 ;;
 ;; If a single value is provided, it will be kept the same for all simulations.
 ;; For a list of values, the list will be randomly sampled from in each simulation.
 ;; For a range of values, the range [inclusive exclusive] will be randomly sampled from in each simulation.
 :temperature               (50 65 80)     ; (degrees Fahrenheit)
 :relative-humidity         (1 10 20)      ; (%)
 :wind-speed-20ft           (10 15 20)     ; (miles/hour)
 :wind-from-direction       (0 90 180 270) ; (degrees clockwise from north)
 :foliar-moisture           90             ; (%)

 ;; Section 4: Number of simulations and (optional) random seed parameter
 :max-runtime               60             ; (minutes)
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :simulations               10
 :random-seed               1234567890     ; long value (optional)

 ;; Section 5: Types and names of outputs
 :outfile-suffix            "_tile_100"
 :output-landfire-inputs?   true
 :output-geotiffs?          true
 :output-pngs?              true
 :output-csvs?              true}
#+end_src

Here is a complete sample configuration for reading both the LANDFIRE
layers, initial burn perimeter, and weather layers from GeoTIFF
files on disk.

#+name: sample_geotiff_config.edn
#+begin_src clojure :results silent :exports code :tangle ../resources/sample_geotiff_config.edn :padline no :no-expand :comments link
{;; Section 1: Landscape data to be shared by all simulations
 :landfire-layers           {:aspect             {:type   :geotiff
                                                  :source "test/gridfire/resources/asp.tif"}
                             :canopy-base-height {:type   :geotiff
                                                  :source "test/gridfire/resources/cbh.tif"}
                             :canopy-cover       {:type   :geotiff
                                                  :source "test/gridfire/resources/cc.tif"}
                             :canopy-height      {:type   :geotiff
                                                  :source "test/gridfire/resources/ch.tif"}
                             :crown-bulk-density {:type   :geotiff
                                                  :source "test/gridfire/resources/cbd.tif"}
                             :elevation          {:type   :geotiff
                                                  :source "test/gridfire/resources/dem.tif"}
                             :fuel-model         {:type   :geotiff
                                                  :source "test/gridfire/resources/fbfm40.tif"}
                             :slope              {:type   :geotiff
                                                  :source "test/gridfire/resources/slp.tif"}}
 :srid                      "CUSTOM:900914"
 :cell-size                 98.425         ; (feet)

 ;; Section 2: Ignition data from which to build simulation inputs
 :ignition-layer            {:type   :geotiff
                             :source "test/gridfire/resources/ign.tif"}

 ;; Section 3: Weather data from which to build simulation inputs
 ;; For all options in this section, you may enter values in one of five ways:
 ;;   1. Single Value: 25
 ;;   2. List of Values: (2 17 9)
 ;;   3. Range of Values: [10 20]
 ;;   4. Raster from file on disk: {:type :gotiff :source "path/to/file/weather.tif"}
 ;;   5. Raster from Postgresql database: {:type :geotiff :source "weather.ws WHERE rid=1"}
 ;;
 ;; If a single value is provided, it will be kept the same for all simulations.
 ;; For a list of values, the list will be randomly sampled from in each simulation.
 ;; For a range of values, the range [inclusive exclusive] will be randomly sampled from in each simulation.

 :temperature                      {:type   :geotiff
                                    :source "test/gridfire/resources/weather-test/tmpf_to_sample.tif"} ; (degrees Fahrenheit)
 :relative-humidity                {:type   :geotiff
                                    :source "test/gridfire/resources/weather-test/rh_to_sample.tif"}   ; (%)
 :wind-speed-20ft                  {:type   :geotiff
                                    :source "test/gridfire/resources/weather-test/ws_to_sample.tif"}   ; (miles/hour)
 :wind-from-direction              {:type   :geotiff
                                    :source "test/gridfire/resources/weather-test/d_to_sample.tif"}    ; (degrees clockwise from north)
 :foliar-moisture                  90                                                                  ; (%)

 ;; Section 4: Number of simulations and (optional) random seed parameter
 :max-runtime               60             ; (minutes)
 :ellipse-adjustment-factor 1.0            ; (< 1.0 = more circular, > 1.0 = more elliptical)
 :simulations               10
 :random-seed               1234567890     ; long value (optional)

 ;; Section 5: Types and names of outputs
 :outfile-suffix            "_from_raster_ignition"
 :output-landfire-inputs?   true
 :output-geotiffs?          true
 :output-pngs?              true
 :output-csvs?              true}
#+end_src

This concludes our discussion of GridFire's command line interface.

#+LATEX: \bibliographystyle{plainnat}
#+LATEX: \bibliography{GridFire}

* Monte Carlo Simulation                                           :noexport:

#+name: monte-carlo-simulation
#+begin_src clojure :results silent :exports none :tangle ../src/gridfire/monte_carlo.clj :padline no :no-expand :comments link
(ns gridfire.monte-carlo
  (:require [clojure.java.io :as io]
            [clojure.data.csv :as csv]
            [clojure.java.jdbc :as jdbc]
            [clojure.core.matrix :as m]
            [clojure.core.matrix.operators :as mop]
            [clojure.core.reducers :as r]
            [gridfire.surface-fire :refer [degrees-to-radians]]
            [gridfire.fire-spread :refer [random-cell run-fire-spread]]
            [gridfire.postgis-bridge :refer [postgis-raster-to-matrix]]))

(m/set-current-implementation :vectorz)

(defn postprocess-simulation-results
  [wrf-cell-id lon lat cell-offset-in-neighborhood output-directory results-table]
  (let [num-fires (count results-table)]
    (with-open [out-file (io/writer (io/file output-directory (str "all-fires-" wrf-cell-id ".csv")))]
      (csv/write-csv out-file
                     (cons ["wrf_cell_id" "lon" "lat" "landfire_y" "landfire_x" "offwig_percentile"
                            "ws_20ft_mph" "wdir" "mparam" "lw_moisture" "eaf" "fire_size_ac" "flame_length_mean"
                            ;; "flame_length_stddev" "fire_volume" "fire_shape"]
                            "fire_volume" "fire_shape"]
                           (mapv (fn [{:keys [ignition-site weather-sample wind-speed-20ft wind-from-direction
                                              equilibrium-moisture lw-moisture eaf fire-size flame-length-mean
                                              ;; flame-length-stddev fire-volume fire-shape]}]
                                              fire-volume fire-shape]}]
                                   (let [local-site     (mop/- ignition-site cell-offset-in-neighborhood)
                                         wrf-percentile (- 100.0 (/ weather-sample 36.0))]
                                     [wrf-cell-id
                                      lon
                                      lat
                                      (local-site 0)
                                      (local-site 1)
                                      wrf-percentile
                                      wind-speed-20ft
                                      wind-from-direction
                                      equilibrium-moisture
                                      lw-moisture
                                      eaf
                                      fire-size
                                      flame-length-mean
                                      ;; flame-length-stddev
                                      fire-volume
                                      fire-shape]))
                                 (sort-by :ignition-site results-table)))))
    (format "%s,%s,%s,%.2f,%.2f,%.2f,%.2f\n"
            wrf-cell-id lon lat
            (/ (transduce (map :fire-size)         + 0.0 results-table) num-fires)
            (/ (transduce (map :flame-length-mean) + 0.0 results-table) num-fires)
            (/ (transduce (map :fire-volume)       + 0.0 results-table) num-fires)
            (/ (transduce (map :fire-shape)        + 0.0 results-table) num-fires))))

(defn cells-to-acres
  [cell-size num-cells]
  (let [acres-per-cell (/ (* cell-size cell-size) 43560.0)]
    (* acres-per-cell num-cells)))

(defn compute-fire-behavior-metrics!
  [weather-readings lw-moisture burn-duration cell-size landfire-layers
   ellipse-adjustment-factor ignition-site weather-sample]
  (let [weather-reading      (get weather-readings weather-sample)
        wind-speed-20ft      (weather-reading :ws)     ;; mph
        wind-from-direction  (mod (+ 15 (weather-reading :wd)) 360) ;; degrees (+15 for WRF->AEA warping)
        equilibrium-moisture (weather-reading :mparam) ;; % (0-100)
        fuel-moisture        {:dead {:1hr        (* (+ equilibrium-moisture 0.2) 0.01)
                                     :10hr       (* (+ equilibrium-moisture 1.5) 0.01)
                                     :100hr      (* (+ equilibrium-moisture 2.5) 0.01)}
                              :live {:herbaceous 0.30
                                     :woody      (* lw-moisture 0.01)}}
        foliar-moisture      0.90
        fire-results         (run-fire-spread burn-duration cell-size landfire-layers
                                              wind-speed-20ft wind-from-direction
                                              fuel-moisture foliar-moisture
                                              ellipse-adjustment-factor ignition-site)]
    (if fire-results
      (let [flame-lengths       (filterv pos? (m/eseq (:flame-length-matrix fire-results)))
            burned-cells        (count flame-lengths)
            fire-size           (cells-to-acres cell-size burned-cells)
            flame-length-mean   (/ (m/esum flame-lengths) burned-cells)
            ;; flame-length-stddev (->> flame-lengths
            ;;                          (m/emap #(Math/pow (- flame-length-mean %) 2.0))
            ;;                          (m/esum)
            ;;                          (#(/ % burned-cells))
            ;;                          (Math/sqrt))]
            ]
        {:ignition-site        ignition-site
         :weather-sample       weather-sample
         :wind-speed-20ft      wind-speed-20ft
         :wind-from-direction  wind-from-direction
         :equilibrium-moisture equilibrium-moisture
         :lw-moisture          lw-moisture
         :eaf                  ellipse-adjustment-factor
         :fire-size            fire-size
         :flame-length-mean    flame-length-mean
         ;; :flame-length-stddev  flame-length-stddev
         :fire-volume          (* fire-size flame-length-mean)
         :fire-shape           (/ fire-size flame-length-mean)})
      {:ignition-site        ignition-site
       :weather-sample       weather-sample
       :wind-speed-20ft      wind-speed-20ft
       :wind-from-direction  wind-from-direction
       :equilibrium-moisture equilibrium-moisture
       :lw-moisture          lw-moisture
       :eaf                  ellipse-adjustment-factor
       :fire-size            0.0
       :flame-length-mean    0.0
       ;; :flame-length-stddev  0.0
       :fire-volume          0.0
       :fire-shape           0.0})))

(defn run-monte-carlo-fire-spread
  "Returns a vector of maps with the following fields:
   {:ignition-site :weather-sample :wind-speed-20ft :wind-from-direction :equilibrium-moisture
    :eaf :fire-size :flame-length-mean :flame-length-stddev :fire-volume :fire-shape}
   Inputs include:
   - landfire-layers  (map of core.matrix 2D double arrays)
                      {:elevation          m
                       :slope              degrees
                       :aspect             degrees from north
                       :fuel-model         category
                       :canopy-height      m
                       :canopy-base-height m
                       :crown-bulk-density kg/m^3
                       :canopy-cover       % (0-100)}
   - cell-size        cell size of matrices in landfire-layers (ft)
   - ignition-sites   (vector of [i j] points)
   - weather-readings (vector of weather records)
                      [{:ws mph :wd degrees :mparam %} ...]
   - lw-moisture      live woody fuel moisture % (0-100+)
   - samples-per-site (no-arg fn that produces a sequence of indices into weather-readings)
   - burn-duration    maximum time to allow each fire to spread (mins)
   - ellipse-adjustment-factor (< 1.0 = more circular, > 1.0 = more elliptical)"
  [landfire-layers cell-size ignition-sites weather-readings lw-moisture max-wrf-sample-index
   burn-duration ellipse-adjustment-factor]
  (let [landfire-layers (assoc landfire-layers
                               :elevation          (m/emap #(* % 3.28) (landfire-layers :elevation)) ; m -> ft
                               :slope              (m/emap #(Math/tan (degrees-to-radians %)) (landfire-layers :slope)) ; degrees -> %
                               :canopy-height      (m/emap #(* % 3.28) (landfire-layers :canopy-height)) ; m -> ft
                               :canopy-base-height (m/emap #(* % 3.28) (landfire-layers :canopy-base-height)) ; m -> ft
                               :crown-bulk-density (m/emap #(* % 0.0624) (landfire-layers :crown-bulk-density)))] ; kg/m^3 -> lb/ft^3
    (mapv (fn [ignition-site]
            (let [weather-sample (rand-int max-wrf-sample-index)]
              (compute-fire-behavior-metrics! weather-readings lw-moisture burn-duration cell-size
                                              landfire-layers ellipse-adjustment-factor ignition-site weather-sample)))
          ignition-sites)))

(defn fetch-wrf-cell-ids
  "Returns a vector of all unique wrf_cell_id strings."
  [db-spec]
  (let [query (str "SELECT j_i AS wrf_cell_id, lon, lat, lw_moisture"
                   "  FROM weather.wrf_points_ca"
                   "  ORDER BY lw_moisture DESC")]
    (jdbc/with-db-transaction [conn db-spec]
      (vec (jdbc/query conn [query])))))

(defn fetch-extreme-weather-readings
  "Returns a vector of maps for each of the top 2% weather readings by
   FFWI with these units:
   {:rank   1-73 (1 = 100th percentile, 73 = 98th percentile)
    :ws     mph (* 0.87 to adjust from 10m winds to 20ft winds)
    :wd     degrees from north
    :mparam 10 * % (0-1000)}"
  [db-spec wrf-cell-id]
  (let [query (str "SELECT rank, 0.87*ows_mph AS ws, wd_deg AS wd, mparam::int AS mparam"
                   "  FROM weather.toptwo_full_daily"
                   "  WHERE j_i_wrf_cacut='" wrf-cell-id "'"
                   "  ORDER BY rank")]
     (jdbc/with-db-transaction [conn db-spec]
       (vec (jdbc/query conn [query])))))

(defn fetch-midrange-weather-readings
  "Returns a vector of maps for each of the 74-76% weather readings by
   FFWI with these units:
   {:rank   1-73 (1 = 100th percentile, 73 = 98th percentile)
    :ws     mph (* 0.87 to adjust from 10m winds to 20ft winds)
    :wd     degrees from north
    :mparam 10 * % (0-1000)}"
  [db-spec wrf-cell-id]
  (let [query (str "SELECT rank, 0.87*ows_mph AS ws, wd_deg AS wd, mparam::int AS mparam"
                   "  FROM weather.midtwo_full_daily"
                   "  WHERE j_i_wrf_cacut='" wrf-cell-id "'"
                   "  ORDER BY rank")]
     (jdbc/with-db-transaction [conn db-spec]
       (vec (jdbc/query conn [query])))))

(defn fetch-landfire-data
  "Returns a map of LANDFIRE rasters as core.matrix 2D double arrays:
   {:elevation          m
    :slope              degrees
    :aspect             degrees
    :fuel-model         category
    :canopy-height      m
    :canopy-base-height m
    :crown-bulk-density kg/m^3
    :canopy-cover       % (0-100)}"
  [db-spec wrf-cell-id]
  (let [landfire-data
        {:elevation          (:matrix (postgis-raster-to-matrix db-spec (str "landfire.dem_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :slope              (:matrix (postgis-raster-to-matrix db-spec (str "landfire.slp_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :aspect             (:matrix (postgis-raster-to-matrix db-spec (str "landfire.asp_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :fuel-model         (:matrix (postgis-raster-to-matrix db-spec (str "fuel_model.fmod_iet_veg2015_wrf_tiles WHERE j_i='" wrf-cell-id "'")))
         ;; :fuel-model         (:matrix (postgis-raster-to-matrix db-spec (str "fuel_model.fmod_reax_v2005_wrf_tiles  WHERE j_i='" wrf-cell-id "'")))
         :canopy-height      (:matrix (postgis-raster-to-matrix db-spec (str "landfire.ch_wrf_tiles                 WHERE j_i='" wrf-cell-id "'")))
         :canopy-base-height (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cbh_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :crown-bulk-density (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cbd_wrf_tiles                WHERE j_i='" wrf-cell-id "'")))
         :canopy-cover       (:matrix (postgis-raster-to-matrix db-spec (str "landfire.cc_wrf_tiles                 WHERE j_i='" wrf-cell-id "'")))}]
    (if (not-any? nil? (vals landfire-data))
      landfire-data)))

(defn read-wrf-cells-list [clj-file start end]
  (-> (slurp clj-file)
      (read-string)
      (subvec start end)))

(defn launch-calfire-monte-carlo-simulation
  [db-spec output-directory wrf-cells-file start end fold-bin-size]
  ;; 1. Read in a list of wrf-cell-ids to process [{:wrf_cell_id :lon :lat :lw_moisture}...]
  ;; 2. Iterate through the wrf-cell-ids sequentially
  ;;    1. Load the live woody fuel moisture
  ;;    2. Load the top 2% extreme FFWI weather dataset as a vector of maps
  ;;    3. Load the LANDFIRE data
  ;;    4. Randomly select 1000 distinct LANDFIRE ignition-sites as a sequence of [i j] points
  ;;    5. Run run-monte-carlo-fire-spread for this WRF cell
  ;;    6. Write results-table to disk as a CSV
  (let [landfire-cell-size          98.425 ;; ft
        calfire-burn-duration       60.0   ;; mins
        max-wrf-sample-index        73
        ellipse-adjustment-factor   1.0
        cell-offset-in-neighborhood [84 83]
        num-ignitions               1000]
    (->> (read-wrf-cells-list wrf-cells-file start end)
         (r/filter (fn [{:keys [wrf_cell_id]}]
                     (not (.exists (io/file output-directory (str "all-fires-" wrf_cell_id ".csv"))))))
         (r/map (fn [{:keys [wrf_cell_id lon lat lw_moisture]}]
                  (try (let [ignition-sites   (into []
                                                    (comp (distinct) (take num-ignitions))
                                                    (repeatedly #(mop/+ cell-offset-in-neighborhood (random-cell 84 83))))
                             weather-readings (fetch-midrange-weather-readings db-spec wrf_cell_id)]
                         (when-let [landfire-data (fetch-landfire-data db-spec wrf_cell_id)]
                           (->> (run-monte-carlo-fire-spread landfire-data landfire-cell-size ignition-sites weather-readings lw_moisture
                                                             max-wrf-sample-index calfire-burn-duration ellipse-adjustment-factor)
                                (postprocess-simulation-results wrf_cell_id lon lat cell-offset-in-neighborhood output-directory))))
                       (catch Exception e (println "Exception in" wrf_cell_id "->" e)))))
         (r/remove nil?)
         (r/fold fold-bin-size r/cat r/append!)
         (cons "wrf_cell_id,lon,lat,fire_size,flame_length,fire_volume,fire_shape")
         (spit (io/file output-directory "all-fires-summary.csv")))))

(comment
  (spit "/data/CALFIRE_MAP1_RUN6/inputs/wrf_cells_to_process.clj"
        (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//iwap03:5432/calfire"
                             :user        "gridfire"}))

  (spit "/data/CALFIRE_MAP1_RUN6/inputs/wrf_cells_to_process.clj"
        (filterv (fn [{:keys [wrf_cell_id]}]
                   (not (.exists (io/file "/data/CALFIRE_MAP1_RUN6/outputs" (str "all-fires-" wrf_cell_id ".csv")))))
                 (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                                      :subprotocol "postgresql"
                                      :subname     "//iwap03:5432/calfire"
                                      :user        "gridfire"})))

  (spit "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
        (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                             :subprotocol "postgresql"
                             :subname     "//iwap03:5432/calfire"
                             :user        "gridfire"}))

  (spit "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
        (filterv (fn [{:keys [wrf_cell_id]}]
                   (not (.exists (io/file "/data/IWAP_GRIDFIRE_RUNS/outputs" (str "all-fires-" wrf_cell_id ".csv")))))
                 (fetch-wrf-cell-ids {:classname   "org.postgresql.Driver"
                                      :subprotocol "postgresql"
                                      :subname     "//iwap03:5432/calfire"
                                      :user        "gridfire"})))

  ;; iwap02
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   0 6000 30)

  ;; iwap03
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//localhost:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   6000 18000 100)

  ;; iwap04
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   18000 30000 100)

  ;; iwap05
  (launch-calfire-monte-carlo-simulation
   {:classname   "org.postgresql.Driver"
    :subprotocol "postgresql"
    :subname     "//iwap03:5432/calfire"
    :user        "gridfire"}
   "/data/IWAP_GRIDFIRE_RUNS/outputs"
   "/data/IWAP_GRIDFIRE_RUNS/inputs/wrf_cells_to_process.clj"
   30000 41423 100))
#+end_src
